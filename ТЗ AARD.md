# ТЕХНИЧЕСКОЕ ЗАДАНИЕ
## Разработка ПО «Автономная агентная платформа развития (AARD)»
### (Autonomous Agentic Recursive Development)
**Версия:** 1.1 (Обновленная)
**Дата:** 2025-01-12
**Последнее обновление:** 2025-01-12

**Изменения в версии 1.1:**
- Добавлены детальные спецификации протокола A2A (раздел 7.3)
- Расширена мультимодельная архитектура с учетом реальной инфраструктуры (раздел 7.4)
- Добавлено управление ресурсами и очередями (раздел 7.6)
- Добавлено управление состоянием и восстановлением (раздел 7.7)
- Добавлена детальная спецификация схемы БД (раздел 7.8)
- Добавлена информация о производительности и масштабируемости (раздел 7.9)
- Обновлен раздел инфраструктуры с реальными параметрами (раздел 8.2)
- Добавлен раздел "Начало работы" с checklist для MVP (раздел 9)

---

## 1. ОБЩЕЕ ОПИСАНИЕ

### 1.1. Предмет разработки
Разработка ПО-оболочки для создания и управления автономными ИИ-агентами, работающей в полностью локальном окружении (Ollama + Postgres/pgvector), которая:

1. **Начинается как "голый мозг"** (LLM через Ollama) с веб-интерфейсом для общения с человеком
2. **Развивается под руководством человека**, создавая себе "тело и нервную систему" (агентов, инструменты, оркестрацию)
3. **Работает под полным контролем человека** с уровнями автономности от ручного до полного автомата
4. **Способна к саморазвитию** через анализ ошибок, обратную связь и эволюцию промптов
5. **Поддерживает мультиагентные системы** с A2A взаимодействием и специализированными моделями (заглушка на старте)

### 1.2. Ключевые инновации
- **Растущая система:** Эволюция от простого чата к сложной агентной экосистеме
- **Контроль человека:** Многоуровневая система утверждения всех действий
- **Agent Ops:** Полный жизненный цикл управления агентами
- **Безопасность:** Идентичность агентов, политики доступа, изоляция выполнения
- **Самообучение:** Долговременная память, улучшение промптов, анализ ошибок
- **Тестирование:** Agent Gym для безопасного тестирования и развития

### 1.3 Границы системы
- Локальные компоненты: Ollama, Postgres, самогенерируемый код
- Разрешенные внешние подключения (только после утверждения):
  * API поиска (Google, Bing)
  * VoIP-сервисы (Twilio, Asterisk)
  * Облачные хранилища (S3, GCS)
- Запрещенные действия без явного разрешения:
  * Изменение системных файлов
  * Доступ к личным данным пользователя
  * Финансовые транзакции

---

## 2. КОНЦЕПЦИЯ СИСТЕМЫ: "РАСТУЩАЯ СИСТЕМА"

### 2.1. Философия развития
AARD начинает с минимальной функциональности и развивается в диалоге с пользователем:

**Исходное состояние (День 0):**
- Веб-интерфейс для общения
- Подключенная LLM через Ollama (одна базовая модель)
- Простая система управления задачами
- Отсутствие агентов и инструментов

**Процесс развития:**
1. **Запрос пользователя** → Анализ потребностей и возможностей
2. **Создание недостающего** → Генерация агентов/инструментов
3. **Утверждение человеком** → Контроль качества и безопасности
4. **Интеграция** → Добавление в работающую систему
5. **Обучение** → Улучшение на основе опыта
6. **Эволюция** → Создание более сложных систем

**Целевое состояние:**
- Экосистема специализированных агентов
- Библиотека проверенных инструментов
- Сложные workflow и оркестрация
- Самооптимизирующиеся промпты
- Надежная система безопасности

### 2.2. Новая парадигма разработки

#### 2.2.1. Смена ролей разработчика
Разработчик становится не писателем кода, а **архитектором поведения** и **наставником интеллекта**.

**Традиционная разработка vs Агент-ориентированная разработка:**
| Аспект | Традиционная разработка | Агент-ориентированная разработка |
|--------|-------------------------|----------------------------------|
| **Основная деятельность** | Написание кода | Настройка промптов и ограничений |
| **Отношение к системе** | Архитектор-строитель | Директор-наставник |
| **Единица разработки** | Класс/функция | Агент/инструмент |
| **Тестирование** | Unit/интеграционные тесты | Agent Gym, трассировки |
| **Отладка** | Логи, дебаггер | Анализ трассировок, промптов |

#### 2.2.2. Новые роли в системе
| Роль | Обязанности | Инструменты |
|------|-------------|-------------|
| **Директор агентов** | Стратегическое направление, установление ограничений | Dashboard метрик, система ограничений |
| **Архитектор агентной системы** | Проектирование архитектуры, определение связей | Визуальный конструктор, шаблоны |
| **Наставник агентов** | Обучение и корректировка поведения агентов | Интерфейс feedback, A/B тестирование |
| **Аудитор безопасности** | Проверка безопасности создаваемых компонентов | Статический анализ, пентест-инструменты |
| **Менеджер развития** | Контроль направления развития системы | Метрики развития, политики, roadmap |

#### 2.2.3. Практики эффективного управления
- **Итеративное уточнение:** От широких директив к конкретике
- **Баланс автономности:** Свобода в рамках границ, эскалация при неопределенности
- **Коллаборативное развитие:** Агенты как партнеры, взаимное обучение
- **Контроль дрейфа целей:** Регулярный аудит соответствия задачам
- Механизмы регулярного аудита соответствия текущих действий исходным целям
- Систему обнаружения и предупреждения о "дрейфе целей"
- Процедуры пересмотра и корректировки направления развития
- Метрики для оценки соответствия системе целей

### 2.3. Уровни автономности
Уровень устанавливается глобально или на конкретную задачу:

| Уровень | Название | Описание | Примеры |
|---------|----------|----------|---------|
| **0** | Ручной (Manual) | Все шаги требуют подтверждения | Создание любого нового инструмента |
| **1** | Полуавтомат (Semi-Auto) | Безопасные действия автоматически, рискованные — с подтверждением | Создание Docker-образа, доступ к сетям |
| **2** | Автомат (Full Auto) | Полная автономность в рамках задачи | Выполнение ранее утверждённых операций |

---

## 3. AGENT OPS: УПРАВЛЕНИЕ ЖИЗНЕННЫМ ЦИКЛОМ АГЕНТОВ

### 3.1. Отладка через трассировки OpenTelemetry
**Цель:** Ответ на вопрос "Почему?" при возникновении проблем.

**Реализация:**
- Интеграция OpenTelemetry SDK во все компоненты
- Иерархические трассировки: задача → план → шаг → действие
- Контекстные метки: агент, инструмент, модель, пользователь

**Веб-интерфейс:**
- Визуализация цепочек выполнения
- Фильтрация по времени, агенту, типу ошибки
- Поиск по контенту трассировок
- Сравнение успешных/неуспешных выполнений

**Использование для отладки:**
- Пошаговое воспроизведение выполнения
- Анализ отклонений от ожидаемого поведения
- Выявление паттернов ошибок
- Интеграция с системой обратной связи

### 3.2. Метрики качества вместо "прошел/не прошел"
**LM Judge система:**
- Отдельная модель для оценки результатов
- Многоаспектная оценка:
  1. **Корректность** (соответствие задаче)
  2. **Полнота** (все ли требования учтены)
  3. **Безопасность** (отсутствие рисков)
  4. **Стиль** (соответствие стандартам)
  5. **Эффективность** (оптимальность решения)

**Автоматизированная оценка:**
- Регулярный прогон через набор тестовых задач
- Сравнительные метрики между версиями агентов
- Ранжирование агентов по специализациям
- Выявление регрессий

### 3.3. Автоматизация обратной связи от людей
**Сбор feedback:**
- Явный: оценки, комментарии, кнопки "нравится/не нравится"
- Неявный: время выполнения, повторные запросы, отмены
- Контекстный: в рамках конкретной задачи или агента

**Обработка feedback:**
- Кластеризация схожих отзывов
- Выявление систематических проблем
- Приоритизация улучшений
- Автоматическое создание тест-кейсов

**Замкнутый цикл улучшения:**
```
Feedback → Анализ → Создание улучшений → Тестирование → Внедрение
```

### 3.4. A/B тестирование агентов
**Инфраструктура тестирования:**
- Параллельное выполнение задач разными версиями
- Случайное распределение задач
- Слепое тестирование (где возможно)

**Метрики сравнения:**
- Качество результатов (оценка LM Judge)
- Скорость выполнения
- Стабильность (процент успешных выполнений)
- Удовлетворенность пользователей

**Процесс продвижения:**
- Статистически значимые результаты
- Постепенное развертывание лучшей версии
- Мониторинг на production нагрузке
- Возможность быстрого отката

### 3.5. Agent Gym: Среда тестирования и развития
**Архитектура Agent Gym:**
```
┌─────────────────────────────────────────────────────────┐
│                    Agent Gym                            │
├─────────────────────────────────────────────────────────┤
│  • Симулятор окружения (Environment Simulator)          │
│  • Генератор синтетических данных (Data Generator)      │
│  • Система оценки (Evaluation System)                   │
│  • Инструменты "красной команды" (Red Team Tools)       │
└─────────────────────────────────────────────────────────┘
```

**Возможности симуляционной среды:**
- Полная изоляция от production-систем
- Возможность тестирования деструктивных сценариев
- Имитация сбоев и нестандартных условий
- Нагрузочное тестирование в контролируемых условиях

**Генерация тестовых данных:**
- Синтетические датасеты различных типов и сложности
- Контролируемое введение аномалий и ошибок
- Вариативность условий выполнения
- Репрезентативность по отношению к реальным задачам

**Система "красной команды":**
- Автоматические тесты на уязвимости безопасности
- Попытки взлома и обхода ограничений
- Тестирование устойчивости к adversarial-атакам
- Проверка граничных условий и edge cases

## 3.6. ЭВОЛЮЦИЯ ПРОМПТОВ: АВТОМАТИЧЕСКОЕ УЛУЧШЕНИЕ ФОРМУЛИРОВОК

### 3.6.1. Многоуровневая система промптов
**Архитектура промптов:**
- **Мета-промпты** (уровень 0): Промпты для создания/оптимизации других промптов
- **Системные промпты** (уровень 1): Общие инструкции для всей системы
- **Агентные промпты** (уровень 2): Специализированные промпты для конкретных агентов
- **Инструментные промпты** (уровень 3): Промпты для работы с конкретными инструментами
- **Контекстные промпты** (уровень 4): Динамически формируемые промпты на основе ситуации

### 3.6.2. Механизмы A/B тестирования промптов

**Процесс тестирования:**
```
1. Генерация вариантов:
   - Базовая версия промпта
   - Альтернативные формулировки (синонимы, структура, детализация)
   - Комбинации успешных элементов из других промптов
   - Экспериментальные формулировки (новые подходы)

2. Параллельное тестирование:
   - Одинаковые задачи выполняются разными версиями промптов
   - Рандомизированное распределение задач
   - Контрольные группы для чистоты эксперимента

3. Сбор метрик:
   - Качество результатов (оценка LM Judge)
   - Время выполнения
   - Стабильность (процент успешных выполнений)
   - Стоимость выполнения (если используются платные модели)
   - Удовлетворенность пользователей

4. Статистический анализ:
   - Определение статистически значимых различий
   - Корреляция с типом задачи, сложностью, контекстом
   - Анализ взаимодействий между элементами промптов
```

### 3.6.3. Автоматическое определение эффективных шаблонов

**Методы анализа эффективности:**

1. **Паттерн-майнинг:**
   - Выявление повторяющихся успешных конструкций
   - Анализ зависимости эффективности от структуры промпта
   - Кластеризация промптов по стилю и подходу

2. **Корреляционный анализ:**
   - Связь конкретных фраз с успешностью выполнения
   - Влияние длины, сложности, стиля на результаты
   - Зависимость от типа модели и параметров

3. **Причинно-следственный анализ:**
   - Выявление причин улучшения/ухудшения качества
   - Анализ цепочек "изменение промпта → изменение поведения"
   - Построение графа влияний элементов промпта

### 3.6.4. Интеграция с системой обратной связи

**Источники данных для улучшения:**

1. **Прямая обратная связь:**
   - Рейтинги пользователей
   - Комментарии и исправления
   - Экспертная оценка результатов

2. **Косвенная обратная связь:**
   - Статистика использования (какие промпты используются чаще)
   - Паттерны повторных запросов (где промпт не сработал с первого раза)
   - Анализ трассировок выполнения

3. **Контекстуальная обратная связь:**
   - Эффективность промпта в разных контекстах
   - Адаптация к стилю конкретного пользователя
   - Учет специфики предметной области

**Цикл улучшения:**
```
[Текущий промпт] → [Сбор обратной связи] → [Анализ паттернов] → 
[Генерация улучшений] → [A/B тестирование] → [Выбор лучшего] → 
[Обновление промпта] → [Мониторинг] → ...
```

### 3.6.5. Метрики для оценки эффективности промптов

**Качественные метрики:**

1. **Релевантность:**
   - Соответствие результата поставленной задаче
   - Полнота охвата требований
   - Отсутствие лишней информации

2. **Качество выполнения:**
   - Техническая корректность
   - Стилистическое соответствие
   - Креативность и нестандартность (где требуется)

3. **Эффективность коммуникации:**
   - Понятность пользователю
   - Удобство дальнейшей обработки
   - Соответствие ожиданиям

**Количественные метрики:**

| Метрика | Формула расчета | Оптимальное значение |
|---------|----------------|----------------------|
| **Коэффициент успешности** | Успешные задачи / Все задачи | > 0.85 |
| **Среднее время выполнения** | Σ(Время выполнения) / N задач | Минимум для типа задачи |
| **Коэффициент повторных запросов** | Повторные запросы / Все запросы | < 0.1 |
| **Пользовательский рейтинг** | Средняя оценка пользователей | > 4.0 / 5.0 |
| **Стоимость выполнения** | Σ(Стоимость) / Задача | Минимум при заданном качестве |

**Специальные метрики:**

4. **Адаптивность:**
   - Способность работать в разных контекстах
   - Устойчивость к вариациям входных данных
   - Гибкость при изменении требований

5. **Предсказуемость:**
   - Консистентность результатов
   - Минимальное количество сюрпризов
   - Соответствие ожиданиям системы

### 3.6.6. Процесс эволюции промптов

**Пошаговый алгоритм:**

1. **Инициализация:**
   - Базовый промпт для нового типа задачи
   - Исторические данные похожих промптов (если есть)
   - Начальный набор вариаций для тестирования

2. **Экспериментальная фаза:**
   - Параллельное тестирование N вариантов
   - Сбор метрик в реальных условиях
   - Статистический анализ результатов

3. **Селекция и рекомбинация:**
   - Отбор наиболее успешных элементов
   - Комбинирование лучших практик
   - Устранение проблемных элементов

4. **Мутация и инновация:**
   - Внесение случайных изменений (контролируемая мутация)
   - Тестирование радикально новых подходов
   - Эксперименты с разными стилями и структурами

5. **Стабилизация:**
   - Фиксация успешной версии
   - Документирование изменений и причин успеха
   - Интеграция в общую базу знаний

### 3.6.7. Инструменты для работы с промптами

**Веб-интерфейс управления промптами:**

1. **Редактор промптов:**
   - Визуальное редактирование с подсветкой
   - Шаблоны и сниппеты
   - История изменений и версионирование

2. **Анализатор эффективности:**
   - Dashboard с метриками по каждому промпту
   - Сравнение версий и вариантов
   - Визуализация трендов

3. **Генератор улучшений:**
   - Автоматические предложения по оптимизации
   - Проверка на противоречия и ошибки
   - Оценка потенциального эффекта

4. **Тестовая среда:**
   - Быстрое тестирование на контрольных задачах
   - Симуляция разных условий
   - A/B тестирование без влияния на production

### 3.6.8. Пример эволюции промпта

**Исходный промпт:**
```
"Создай инструмент для поиска файлов"
```

**Проблемы:**
- Неясно, какие именно файлы и как искать
- Нет критериев качества
- Нет ограничений и требований

**Улучшенная версия 1:**
```
"Создай Python инструмент для поиска файлов по расширению и имени в указанной директории. 
Инструмент должен поддерживать рекурсивный обход, иметь конфигурируемые фильтры и возвращать результаты в формате JSON."
```

**Улучшенная версия 2 (после A/B тестирования):**
```
"Разработай инструмент file_finder.py со следующими характеристиками:
1. Функция поиска файлов по маске имени и расширению
2. Рекурсивный обход вложенных директорий с ограничением глубины
3. Фильтрация по размеру и дате изменения
4. Вывод в JSON с полями: путь, размер, дата_изменения
5. Обработка ошибок доступа с логированием
6. Тесты для основных сценариев использования"
```

**Метрики улучшения:**
- Успешность выполнения: с 45% до 92%
- Время на доработки: с 15 минут до 2 минут
- Качество кода: с 60% до 95% прохождения тестов


---

## 4. ИНТЕРФЕЙС УТВЕРЖДЕНИЯ: ПОЛНЫЙ КОНТРОЛЬ ЧЕЛОВЕКА

### 4.1. Критерии автоматической приостановки
Система автоматически приостанавливает выполнение при:

**Критерии безопасности:**
- Попытка доступа к запрещенным ресурсам
- Обнаружение потенциальных уязвимостей в коде
- Превышение лимитов привилегий
- Подозрительные паттерны поведения

**Критерии качества:**
- Уверенность модели ниже порогового значения
- Противоречивые инструкции или требования
- Обнаружение edge-case, не покрытого тестами
- Результат значительно отклоняется от ожидаемого

**Критерии ресурсов:**
- Превышение лимитов времени/памяти
- Непредвиденно высокая стоимость выполнения
- Конфликт ресурсов с другими задачами

### 4.2. Уровни вовлеченности человека

| Уровень | Описание | Пример использования |
|---------|----------|---------------------|
| **Полная проверка** | Каждый шаг требует явного подтверждения | Создание новых агентов, доступ к критичным системам |
| **Выбор из вариантов** | Система предлагает варианты, человек выбирает | Оптимизация существующих workflow |
| **Пост-фактум одобрение** | Система выполняет, затем отчитывается | Рутинные задачи с низким риском |
| **Только уведомление** | Система выполняет, только уведомляет | Тривиальные задачи, полностью проверенные |

### 4.3. Механизм утверждения артефактов
Для каждого утверждаемого артефакта показывать:

**Обязательные секции:**
1. **Описание артефакта** (что делает, зачем нужно)
2. **Сгенерированный код** с подсветкой синтаксиса и навигацией
3. **Валидация безопасности:**
   - Статический анализ (bandit, safety)
   - Проверка на инъекции (SQL, shell, prompt)
   - Анализ зависимостей (уязвимости, лицензии)
   - Оценка привилегий (что требует)
4. **Результаты тестирования:**
   - Покрытие тестами
   - Успешные/неуспешные тест-кейсы
   - Производительность (время выполнения, память)
5. **Рекомендации системы:**
   - Оценка риска (низкий/средний/высокий)
   - Альтернативные варианты
   - Возможные проблемы и ограничения
6. **История изменений** (если это новая версия)

### 4.4. Упреждающие запросы на основе анализа рисков
**Алгоритм определения необходимости запроса:**
```python
def should_request_human_approval(action, context):
    risk_score = calculate_risk_score(action, context)
    confidence = get_model_confidence(action)
    
    if risk_score > RISK_THRESHOLD_HIGH:
        return "REQUIRED"  # Обязательное подтверждение
    elif risk_score > RISK_THRESHOLD_MEDIUM and confidence < CONFIDENCE_THRESHOLD:
        return "RECOMMENDED"  # Рекомендуется подтверждение
    else:
        return "NOT_NEEDED"  # Не требуется
```

---

## 5. ДОЛГОВРЕМЕННАЯ ПАМЯТЬ СИСТЕМЫ

### 5.1. Архитектура памяти
**Уровни памяти:**
1. **Рабочая память (сессионная):**
   - Контекст текущей задачи
   - Временные переменные и промежуточные результаты
   - Очищается по завершении задачи

2. **Эпизодическая память (опыт выполнения):**
   - История выполненных задач с результатами
   - Трассировки успешных и неудачных выполнений
   - Извлеченные уроки и паттерны

3. **Семантическая память (знания):**
   - Факты и концепции, полученные в процессе работы
   - Документация созданных инструментов и агентов
   - Лучшие практики и анти-паттерны

4. **Процедурная память (навыки):**
   - Оптимизированные промпты для разных типов задач
   - Шаблоны решений проверенных проблем
   - Эффективные последовательности действий

### 5.2. RAG-система на основе pgvector
- Автоматическая индексация всех создаваемых артефактов
- Семантический поиск по прошлому опыту
- Контекстуальное извлечение релевантной информации
- Взвешивание результатов по релевантности и качеству

**Механизмы актуализации знаний:**
- Периодический пересмотр устаревшей информации
- Обнаружение противоречий в знаниях
- Приоритизация актуальных источников
- Механизмы забывания маловажной информации

### 5.3 Механизмы забывания и актуализации
1. Время жизни записей:
   - Быстро меняющиеся данные: 7 дней
   - Стабильные знания: 90 дней
   - Фундаментальные принципы: бессрочно

2. Критерии актуальности:
   - Частота использования (weight = 0.4)
   - Дата последнего подтверждения (weight = 0.3)
   - Источник информации (weight = 0.3)

3. Формула приоритета:
   приоритет = 0.4*частота + 0.3*подтверждение + 0.3*источник
   записи с приоритетом < 0.5 удаляются автоматически

---

## 6. БЕЗОПАСНОСТЬ АГЕНТОВ

### 6.1. Идентичность агентов как отдельной сущности
**Три типа субъектов в системе:**
1. **Пользователи** (люди) - полная автономия и ответственность
2. **Агенты** (автономные программы) - действуют от имени пользователей
3. **Служебные учетные записи** (детерминированные программы) - не имеют автономии

**Идентификация агентов:**
- Уникальный цифровой идентификатор (SPIFFE ID)
- Сертификаты для криптографической верификации
- Метки и атрибуты (создатель, версия, назначение)
- История действий и репутационный скоринг

### 6.2. Механизмы аутентификации и авторизации
**Аутентификация агентов (AuthN):**
- Использование стандарта SPIFFE/SPIRE
- Машинные сертификаты с коротким временем жизни
- Ротация ключей и автоматическое обновление
- Аудит всех аутентификационных событий

**Авторизация действий (AuthZ):**
- Политики доступа на основе атрибутов (ABAC)
- Принцип минимальных привилегий
- Контекстно-зависимые разрешения
- Динамическое изменение прав в зависимости от ситуации

### 6.3. Политики ограничения доступа
**Уровни контроля:**
1. **Системный уровень:** глобальные политики безопасности
2. **Агентный уровень:** права конкретного агента
3. **Инструментальный уровень:** ограничения для инструментов
4. **Сессионный уровень:** временные ограничения на выполнение задачи

**Пример политик:**
```yaml
agent_security_policies:
  - agent_type: "data_access"
    allowed_actions: ["read", "filter", "aggregate"]
    forbidden_actions: ["delete", "modify_schema"]
    data_sensitivity: ["public", "internal"]
    
  - agent_type: "network_operations"
    requires_approval_for: ["port_scan", "new_connection"]
    rate_limits: 
      requests_per_minute: 10
      data_transfer_mb: 100
```

### 6.4. Матрица ответственности
```
┌─────────────────┬──────────────────┬──────────────────┐
│     Субъект     │   Автономность   │  Ответственность  │
├─────────────────┼──────────────────┼──────────────────┤
│ Пользователь    │ Полная           │ Полная           │
│ Агент           │ Делегированная   │ Разделенная      │
│ Система         │ Нет              │ Техническая      │
└─────────────────┴──────────────────┴──────────────────┘
```

---

## 7. АРХИТЕКТУРА СИСТЕМЫ

### 7.1. Компоненты системы
```
┌─────────────────────────────────────────────────────────┐
│                  Веб-интерфейс                          │
│  - Чат с системой                                      │
│  - Утверждение создаваемых артефактов                  │
│  - Мониторинг выполнения                               │
│  - Управление агентами и инструментами                 │
└─────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────┐
│               Ядро системы (Core Engine)                │
├─────────────────────────────────────────────────────────┤
│  • Task Manager (управление задачами)                  │
│  • Planner (планировщик высокого уровня)               │
│  • Artifact Generator (генератор агентов/инструментов) │
│  • A2A Orchestrator (оркестрация взаимодействий)       │
│  • Agent Ops Manager (управление жизненным циклом)     │
│  • Memory System (долговременная память)               │
└─────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────┐
│                 Слой выполнения                         │
├─────────────────────────────────────────────────────────┤
│  • Модели (Ollama + заглушки для будущих)              │
│  • Инструменты (локальные и внешние)                   │
│  • Агенты (исполняемые единицы)                        │
│  • Базы данных (Postgres + pgvector)                   │
└─────────────────────────────────────────────────────────┘
```

### 7.2. Схемы данных (ключевые сущности)

**Task (Задача):**
```yaml
id: UUID
description: str  # Описание от пользователя
status: [pending, planning, waiting_approval, executing, paused, completed, failed]
priority: int
created_by: str
created_at: datetime
parent_task_id: UUID?  # для вложенных задач
```

**Artifact (Артефакт - агент или инструмент):**
```yaml
id: UUID
type: [agent, tool]
name: str
description: str
code: str?  # для инструментов
prompt: str?  # для агентов
dependencies: List[UUID]  # зависимости от других артефактов
version: int
status: [draft, waiting_approval, active, deprecated]
test_results: Dict  # результаты автоматического тестирования
security_rating: float  # оценка безопасности (0.0-1.0)
```

**Approval Request (Запрос на утверждение):**
```yaml
id: UUID
artifact_id: UUID
request_type: [new_artifact, artifact_update, execution_step]
risk_assessment: Dict  # оценка рисков
recommendation: str  # рекомендация системы
required_action: [approve, reject, modify]
human_feedback: str?  # фидбек от человека
decision_timeout: datetime  # время ожидания решения
```

**Memory Record (Запись памяти):**
```yaml
id: UUID
content: str  # текстовое содержимое
embedding: vector(768)  # векторное представление
metadata: Dict  # метаданные (тип, источник, дата)
tags: List[str]  # теги для категоризации
access_count: int  # счетчик обращений
last_accessed: datetime  # дата последнего обращения
```

### 7.3. A2A взаимодействие: ДЕТАЛЬНАЯ СПЕЦИФИКАЦИЯ

#### 7.3.1. Протокол Agent-to-Agent (A2A)
**Стандартизированное взаимодействие между агентами с полной спецификацией формата сообщений.**

#### 7.3.2. Формат сообщений A2A
**Полная спецификация формата:**
```yaml
A2AMessage:
  # Заголовок
  message_id: UUID  # Уникальный идентификатор сообщения
  correlation_id: UUID?  # Для связывания request/response
  parent_message_id: UUID?  # Для цепочек сообщений
  
  # Метаданные
  timestamp: datetime  # Время создания (UTC)
  ttl: int  # Time to live в секундах (по умолчанию 300)
  priority: int  # 0-9, где 9 - наивысший
  
  # Участники
  sender:
    agent_id: UUID
    spiffe_id: string
    version: int
    capabilities: List[str]  # Возможности агента
  
  recipient:
    agent_id: UUID | "broadcast" | "multicast"
    filter: Dict?  # Условия для multicast (тип агента, версия, etc.)
  
  # Содержимое
  type: "request|response|notification|error|heartbeat"
  
  payload:
    action: str  # Название действия
    parameters: Dict  # Параметры действия
    context:
      task_id: UUID?
      step_id: UUID?
      user_id: UUID?
      trace_id: string?  # OpenTelemetry trace ID
  
  expected_response_timeout: int?  # Для request типов (секунды)
  
  # Безопасность
  signature: string  # Цифровая подпись сообщения
  encryption: "none|symmetric|asymmetric"
  encryption_key_id: UUID?  # ID ключа для расшифровки
```

#### 7.3.3. Реестр агентов (Agent Registry)
**Service discovery и управление жизненным циклом агентов:**

**Функции:**
- Регистрация и удаление агентов
- Health checks (периодическая проверка доступности)
- Версионирование и управление версиями
- Поиск агентов по возможностям (capabilities)

**Схема реестра:**
```yaml
AgentRegistryEntry:
  agent_id: UUID
  name: str
  version: int
  spiffe_id: string
  status: "active|inactive|deprecated|error"
  capabilities: List[str]  # ["data_processing", "code_generation", etc.]
  metadata:
    created_at: datetime
    last_heartbeat: datetime
    endpoint: string  # URL для коммуникации
    max_concurrent_tasks: int
  health:
    status: "healthy|degraded|unhealthy"
    last_check: datetime
    response_time_ms: int
```

**Health Check механизм:**
- Heartbeat каждые 30 секунд
- Timeout: 5 секунд для ответа
- 3 последовательных пропуска heartbeat → статус "unhealthy"
- Автоматическое удаление из реестра после 5 минут без heartbeat

#### 7.3.4. Типы взаимодействия
**1. Синхронное (Request-Response):**
- Блокирующее ожидание ответа
- Timeout: настраиваемый, по умолчанию 60 секунд
- Автоматический retry при временных ошибках

**2. Асинхронное (Fire-and-Forget):**
- Отправка без ожидания ответа
- Подтверждение получения (acknowledgment)
- Гарантия доставки (at-least-once semantics)

**3. Pub/Sub (Publish-Subscribe):**
- Агенты подписываются на события
- Множественные подписчики для одного события
- Фильтрация событий на стороне подписчика

**4. Streaming:**
- Для длительных операций (генерация кода, обработка больших данных)
- Chunked отправка результатов
- Возможность отмены операции

#### 7.3.5. Обработка ошибок в A2A
**Типы ошибок:**
1. **Delivery Errors:** Сообщение не доставлено
   - Retry с exponential backoff (1s, 2s, 4s, 8s, max 60s)
   - После 5 неудачных попыток → Dead Letter Queue
   
2. **Processing Errors:** Агент не может обработать сообщение
   - Возврат error response с деталями
   - Уведомление отправителя
   - Логирование для анализа

3. **Timeout Errors:** Превышен таймаут обработки
   - Уведомление отправителя о таймауте
   - Возможность повторной попытки
   - Компенсационные действия если необходимо

**Dead Letter Queue (DLQ):**
- Хранение недоставленных/необработанных сообщений
- Возможность повторной обработки после исправления проблемы
- Анализ паттернов ошибок для улучшения системы
- Автоматическое удаление через 7 дней

#### 7.3.6. Безопасность A2A
- Подпись и шифрование всех меж-агентных сообщений
- Верификация цепочки доверия (SPIFFE)
- Защита от replay-атак (nonce, timestamp validation)
- Мониторинг аномальных паттернов коммуникации
- Аудит всех меж-агентных взаимодействий

### 7.4. Мультимодельная архитектура

#### 7.4.1. Интеграция с Ollama: Оптимизация и управление
**Поддержка множественных моделей Ollama с балансировкой нагрузки и кэшированием.**

**Текущая конфигурация:**
```yaml
ollama_config:
  instances:
    - url: "http://10.39.0.101:11434/v1"
      models:
        - name: "huihui_ai/deepseek-r1-abliterated:8b"
          capabilities: ["general", "reasoning", "conversation"]
          max_concurrent: 2
          priority: 1
          server_specs:
            host: "10.39.0.101"
            gpu: "RTX 3070 Ti"
            ram: "80 GB"
      health_check_interval: 30
    
    - url: "http://10.39.0.6:11434/v1"
      models:
        - name: "qwen3-coder:30b-a3b-q4_K_M"
          capabilities: ["coding", "code_generation", "code_analysis"]
          max_concurrent: 1
          priority: 2
          server_specs:
            host: "10.39.0.6"
            gpu: "RTX 3090"
            ram: "32 GB"
      health_check_interval: 30
```

#### 7.4.2. Connection Pool и Request Management
**Управление соединениями:**
- Connection pool к каждому Ollama инстансу
- Автоматическое переподключение при обрыве
- Health check перед использованием соединения
- Балансировка нагрузки между доступными инстансами

**Конфигурация очередей:**
```yaml
request_queue:
  max_size: 100
  timeout: 300  # секунд
  retry_attempts: 3
  retry_delay: 5  # секунд между попытками
```

#### 7.4.3. Выбор модели для задачи
**Алгоритм выбора:**
1. Анализ типа задачи (кодирование, рассуждение, генерация текста)
2. Проверка доступности моделей с нужными capabilities
3. Выбор модели на основе:
   - Соответствие capabilities
   - Текущая загрузка модели
   - Приоритет модели
   - История успешности модели для подобных задач
4. Fallback на альтернативную модель при недоступности основной

**Матрица выбора:**
```yaml
task_type_to_model:
  code_generation: "qwen3-coder:30b-a3b-q4_K_M"
  reasoning: "huihui_ai/deepseek-r1-abliterated:8b"
  general_chat: "huihui_ai/deepseek-r1-abliterated:8b"
  code_analysis: "qwen3-coder:30b-a3b-q4_K_M"
  default: "huihui_ai/deepseek-r1-abliterated:8b"
```

#### 7.4.4. Кэширование результатов LLM
**Уровни кэширования:**
1. **Semantic Cache:**
   - Векторный поиск похожих промптов
   - Порог схожести: 0.95
   - TTL: 24 часа для общих запросов, 7 дней для специализированных

2. **Result Cache:**
   - Кэширование результатов выполнения инструментов
   - Инвалидация при изменении входных параметров
   - Ключ: hash(input_params + tool_version)

3. **Plan Cache:**
   - Кэширование планов для похожих задач
   - Адаптация кэшированных планов к текущему контексту
   - Метрика схожести: >85% для переиспользования плана

#### 7.4.5. Streaming и длительные операции
- Поддержка streaming responses от Ollama
- Прогрессивная обработка частичных результатов
- Возможность отмены длительных операций
- Промежуточные checkpoint для очень длинных генераций

#### 7.4.6. Мониторинг производительности Ollama
**Метрики:**
- Время ответа (P50, P95, P99)
- Успешность запросов (%)
- Текущая загрузка (количество активных запросов)
- Использование GPU/CPU
- Частота ошибок

**Алерты:**
- Время ответа > 30 секунд
- Успешность < 95%
- Модель недоступна
- Превышение лимита concurrent requests

## 7.5. СИСТЕМА ПЛАНИРОВАНИЯ И УПРАВЛЕНИЯ ВЫПОЛНЕНИЕМ

### 7.5.1. Многоуровневая архитектура планирования

**Три уровня планирования:**

1. **Стратегическое планирование (Мета-планировщик):**
   - Анализ общей цели и декомпозиция на подзадачи
   - Определение необходимых ресурсов и ограничений
   - Выбор общей стратегии выполнения
   - Оценка рисков и альтернативных путей

2. **Тактическое планирование (Планировщик задач):**
   - Создание детального пошагового плана
   - Определение последовательности и зависимостей
   - Назначение конкретных агентов/инструментов для каждого шага
   - Расчет временных оценок и контрольных точек

3. **Оперативное планирование (Исполнитель):**
   - Реализация конкретных шагов плана
   - Мониторинг выполнения в реальном времени
   - Адаптация к изменяющимся условиям
   - Обработка ошибок и отклонений

### 7.5.2. Процесс планирования

**Шаги создания плана:**

```
1. Анализ задачи:
   - Понимание цели и требований
   - Определение критериев успеха
   - Идентификация ограничений и условий

2. Декомпозиция:
   - Разбиение на подзадачи и шаги
   - Определение зависимостей между шагами
   - Создание иерархии задач (дерево)

3. Ресурсное планирование:
   - Определение необходимых агентов и инструментов
   - Оценка времени и вычислительных ресурсов
   - Распределение приоритетов

4. Оценка рисков:
   - Идентификация потенциальных проблем
   - Создание альтернативных путей (fallback)
   - Определение точек контроля и утверждения

5. Визуализация и утверждение:
   - Представление плана в понятном формате
   - Утверждение пользователем (при необходимости)
   - Настройка уровня автономности для каждого этапа
```

### 7.5.3. Формат плана

**Структура плана:**
```yaml
plan:
  id: "uuid"
  task_id: "uuid"
  version: 1
  goal: "Описание конечной цели"
  
  strategy:
    approach: "Описание общего подхода"
    assumptions: ["Предположение 1", "Предположение 2"]
    constraints: ["Ограничение 1", "Ограничение 2"]
    success_criteria: ["Критерий 1", "Критерий 2"]
  
  steps:
    - step_id: "step_1"
      description: "Описание шага"
      type: "action|decision|validation|approval"
      agent: "agent_id или null"
      tool: "tool_id или null"
      inputs: { ... }
      expected_outputs: { ... }
      timeout: 300  # секунды
      retry_policy: 
        max_attempts: 3
        delay: 10
      dependencies: []  # шаги, которые должны быть выполнены до этого
      approval_required: true|false
      risk_level: "low|medium|high"
    
    - step_id: "step_2"
      # ... и так далее
  
  alternatives:
    - description: "Альтернативный вариант выполнения"
      trigger_conditions: ["Условие 1", "Условие 2"]
      steps: [ ... ]
  
  monitoring:
    checkpoints: ["Контрольная точка 1", "Контрольная точка 2"]
    metrics_to_track: ["Метрика 1", "Метрика 2"]
    alerts_conditions: ["Условие для алерта 1", "Условие для алерта 2"]
```

### 7.5.4. Механизм перепланирования

**Триггеры для перепланирования:**

1. **Ошибки выполнения:**
   - Сбой шага после всех попыток повтора
   - Недоступность необходимого ресурса
   - Несоответствие результата ожиданиям

2. **Изменение условий:**
   - Появление новой информации
   - Изменение ограничений или требований
   - Обнаружение более эффективного пути

3. **Внешние факторы:**
   - Вмешательство пользователя
   - Изменение приоритетов
   - Ограничение по времени или ресурсам

**Процесс перепланирования:**

```
1. Анализ текущей ситуации:
   - Что пошло не так (или что изменилось)
   - Текущее состояние выполнения
   - Доступные ресурсы и ограничения

2. Генерация вариантов:
   - Корректировка существующего плана
   - Создание альтернативного плана с нуля
   - Комбинация разных подходов

3. Оценка вариантов:
   - Прогноз вероятности успеха
   - Оценка затрат ресурсов
   - Анализ рисков

4. Выбор и утверждение:
   - Автоматический выбор (при низком уровне риска)
   - Предложение пользователю (при среднем/высоком риске)
   - Внесение корректировок по фидбеку

5. Плавный переход:
   - Сохранение результатов выполненных шагов
   - Адаптация контекста к новому плану
   - Минимизация потерь и повторов
```

### 7.5.5. Уровни детализации планов

**Варианты детализации (выбираются пользователем):**

1. **Высокоуровневый план:**
   - Только основные этапы и вехи
   - Минимальная детализация шагов
   - Подходит для простых задач или когда доверяешь системе

2. **Детальный план:**
   - Все шаги с описанием действий
   - Указание конкретных инструментов и параметров
   - Подходит для сложных задач или при обучении системы

3. **Адаптивный план:**
   - Начальный высокоуровневый план
   - Детализация по мере выполнения
   - Возможность углубления в проблемные области

### 7.5.6. Интеграция с другими компонентами

**Взаимодействие планировщика с:**

1. **Долговременной памятью:**
   - Поиск аналогичных планов и их результатов
   - Использование прошлого опыта для оценки рисков
   - Адаптация проверенных шаблонов

2. **Системой безопасности:**
   - Проверка каждого шага на соответствие политикам
   - Оценка рисков безопасности для каждого действия
   - Интеграция точек утверждения для рискованных операций

3. **Agent Ops:**
   - Мониторинг выполнения плана через трассировки
   - Сбор метрик для будущей оптимизации
   - Интеграция с A/B тестированием разных подходов

4. **Интерфейсом утверждения:**
   - Определение, какие шаги требуют утверждения
   - Предоставление контекста для принятия решения
   - Обработка отказов и запросов на изменение

### 7.5.7. Визуализация и управление планами

**Веб-интерфейс для работы с планами:**

1. **Визуализатор планов:**
   - Дерево задач с зависимостями
   - Гант-диаграмма с временными оценками
   - Граф выполнения с текущим статусом

2. **Инструменты управления:**
   - Приостановка/возобновление выполнения
   - Ручное перепланирование отдельных участков
   - Изменение приоритетов и ресурсов

3. **Анализ выполнения:**
   - Сравнение плана с фактическим выполнением
   - Выявление узких мест и проблемных областей
   - Рекомендации по оптимизации будущих планов

### 7.5.8. Примеры использования планирования

**Пример 1: Создание инструмента поиска файлов**

```
План:
1. [Анализ] Понимание требований: поиск по имени, расширению, содержимому
2. [Проектирование] Определение архитектуры: рекурсивный обход, индексация, кэширование
3. [Реализация] Написание кода на Python с использованием os.walk и whoosh
4. [Тестирование] Создание тестов и проверка в изолированной среде
5. [Документирование] Написание документации и примеров использования
6. [Интеграция] Регистрация инструмента в системе
```

**Пример 2: Адаптивное перепланирование при ошибке**

```
Исходный план:
1. Запросить данные из API A
2. Обработать данные
3. Сохранить в базу

Ошибка: API A недоступен

Перепланирование:
Новый план:
1. Попробовать API A еще 2 раза (fallback)
2. Если не работает → использовать API B (альтернатива)
3. Если API B недоступен → запросить данные из локального кэша
4. Если данных в кэше нет → запросить у пользователя
```

---

## 7.6. УПРАВЛЕНИЕ РЕСУРСАМИ И ОЧЕРЕДЯМИ

### 7.6.1. Task Queue Manager
**Назначение:** Управление очередями задач и распределение ресурсов

**Компоненты:**
- **Priority Queue:** Очередь задач с приоритетами (0-9, где 9 - наивысший)
- **Resource Pool:** Пул вычислительных ресурсов (CPU, память, GPU)
- **Rate Limiter:** Ограничение частоты запросов на уровне агентов/инструментов
- **Load Balancer:** Распределение нагрузки между несколькими экземплярами Ollama

**Стратегия распределения ресурсов:**
```yaml
resource_allocation:
  cpu:
    per_agent: "1 core"  # базовое выделение
    max_per_task: "4 cores"  # максимум для одной задачи
    priority_boost: "multiply by priority level"
  
  memory:
    per_agent: "512 MB"
    max_per_task: "4 GB"
    oom_killer: "graceful termination with checkpoint"
  
  gpu:
    ollama_requests:
      max_concurrent: 3  # параллельных запросов к одной модели
      queue_size: 50
      timeout: 300  # секунд
    model_selection:
      strategy: "round_robin|least_loaded|task_based"
```

### 7.6.2. Механизм очередей
**Типы очередей:**
1. **High Priority:** Требуют немедленного выполнения (критические задачи)
2. **Normal:** Стандартные задачи (FIFO с учетом приоритета)
3. **Low Priority:** Фоновые задачи (обработка когда есть свободные ресурсы)
4. **Scheduled:** Задачи с отложенным выполнением

**Алгоритм обработки:**
- Приоритет = базовая_приоритетность × коэффициент_важности × коэффициент_дедлайна
- Graceful degradation: при перегрузке система снижает качество (использует более быстрые модели)
- Автоматическое масштабирование: создание дополнительных worker'ов при высокой нагрузке

### 7.6.3. Кэширование и оптимизация
**Уровни кэширования:**
1. **LLM Response Cache:**
   - Семантическое кэширование (похожие промпты → один ответ)
   - Векторный поиск для определения похожести
   - TTL: 24 часа для общих запросов, 7 дней для специализированных

2. **Execution Result Cache:**
   - Кэширование результатов выполнения инструментов
   - Инвалидация при изменении входных параметров
   - Ключ: hash(input_params + tool_version)

3. **Plan Cache:**
   - Кэширование планов для похожих задач
   - Адаптация кэшированных планов к текущему контексту
   - Метрика схожести: >85% для переиспользования плана

---

## 7.7. УПРАВЛЕНИЕ СОСТОЯНИЕМ И ВОССТАНОВЛЕНИЕМ

### 7.7.1. Checkpoint система
**Назначение:** Сохранение промежуточного состояния выполнения задачи для возможности восстановления

**Типы checkpoint:**
- **Light Checkpoint:** Сохраняет только текущий шаг и результаты предыдущих (каждые 5 минут)
- **Full Checkpoint:** Полное сохранение состояния задачи (перед критическими операциями)
- **Automatic Checkpoint:** Перед каждым утверждением, после успешного выполнения шага

**Что сохраняется:**
```yaml
checkpoint:
  task_id: UUID
  current_step: int
  completed_steps: List[StepResult]
  pending_steps: List[Step]
  context: Dict  # контекст выполнения
  agent_states: Dict  # состояния всех участвующих агентов
  timestamp: datetime
  checkpoint_type: "light|full|automatic"
```

### 7.7.2. Механизм отката (Rollback)
**Возможности отката:**
1. **Artifact Rollback:**
   - Откат агента/инструмента к предыдущей версии
   - Автоматическая замена зависимостей при откате
   - Уведомление о затронутых задачах

2. **Task Rollback:**
   - Восстановление с последнего checkpoint
   - Возможность полного отката задачи (удаление всех созданных артефактов)
   - Компенсационные действия для частично выполненных операций

3. **System Rollback:**
   - Откат к снимку состояния системы (snapshot)
   - Сохранение снимков перед критическими изменениями
   - Версионирование конфигурации системы

**Процесс отката:**
```
1. Определение scope отката (что именно откатываем)
2. Проверка зависимостей (что будет затронуто)
3. Создание резервной копии текущего состояния
4. Выполнение отката
5. Валидация после отката
6. Уведомление о результате
```

### 7.7.3. Транзакционность
**Уровни транзакций:**
1. **Artifact Transaction:** Атомарное создание/обновление артефакта
   - Все операции в рамках одной транзакции
   - Откат при любой ошибке
   - Автоматическая валидация перед коммитом

2. **Task Transaction:** Транзакция выполнения задачи
   - Saga pattern для длительных операций
   - Компенсационные действия для каждого шага
   - Возможность частичного отката

3. **Multi-Agent Transaction:** Распределенные транзакции между агентами
   - Two-Phase Commit для критических операций
   - Timeout и автоматический откат при таймауте
   - Координатор транзакций для управления процессом

**Saga Pattern:**
```yaml
saga:
  id: UUID
  steps:
    - step_id: "step_1"
      action: "create_artifact"
      compensation: "delete_artifact"
    - step_id: "step_2"
      action: "register_agent"
      compensation: "unregister_agent"
  state: "executing|completed|compensating|failed"
```

---

## 7.8. ДЕТАЛЬНАЯ СПЕЦИФИКАЦИЯ СХЕМЫ БАЗЫ ДАННЫХ

### 7.8.1. Ключевые таблицы
**Расширенная схема основных сущностей:**

**Tasks (Задачи):**
```sql
CREATE TABLE tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    description TEXT NOT NULL,
    status VARCHAR(20) NOT NULL CHECK (status IN (
        'pending', 'planning', 'waiting_approval', 
        'executing', 'paused', 'completed', 'failed'
    )),
    priority INTEGER DEFAULT 5 CHECK (priority >= 0 AND priority <= 9),
    created_by VARCHAR(255),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    parent_task_id UUID REFERENCES tasks(id),
    plan_id UUID,
    current_checkpoint_id UUID
);

CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_priority ON tasks(priority);
CREATE INDEX idx_tasks_created_at ON tasks(created_at);
CREATE INDEX idx_tasks_parent ON tasks(parent_task_id);
```

**Artifacts (Артефакты):**
```sql
CREATE TABLE artifacts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    type VARCHAR(10) NOT NULL CHECK (type IN ('agent', 'tool')),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    code TEXT,  -- для инструментов
    prompt TEXT,  -- для агентов
    version INTEGER NOT NULL DEFAULT 1,
    status VARCHAR(20) NOT NULL CHECK (status IN (
        'draft', 'waiting_approval', 'active', 'deprecated'
    )),
    test_results JSONB,
    security_rating FLOAT CHECK (security_rating >= 0 AND security_rating <= 1),
    created_at TIMESTAMP DEFAULT NOW(),
    created_by VARCHAR(255)
);

CREATE TABLE artifact_dependencies (
    artifact_id UUID REFERENCES artifacts(id),
    depends_on_artifact_id UUID REFERENCES artifacts(id),
    PRIMARY KEY (artifact_id, depends_on_artifact_id)
);

CREATE INDEX idx_artifacts_type_status ON artifacts(type, status);
CREATE INDEX idx_artifacts_version ON artifacts(version);
```

**Memory Records (Долговременная память):**
```sql
CREATE TABLE memory_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content TEXT NOT NULL,
    embedding vector(768),  -- pgvector
    metadata JSONB,
    tags TEXT[],
    memory_type VARCHAR(20) CHECK (memory_type IN (
        'episodic', 'semantic', 'procedural', 'working'
    )),
    access_count INTEGER DEFAULT 0,
    last_accessed TIMESTAMP DEFAULT NOW(),
    created_at TIMESTAMP DEFAULT NOW(),
    priority_score FLOAT DEFAULT 0.5
);

CREATE INDEX idx_memory_embedding ON memory_records 
    USING ivfflat (embedding vector_cosine_ops);
CREATE INDEX idx_memory_type ON memory_records(memory_type);
CREATE INDEX idx_memory_tags ON memory_records USING GIN(tags);
CREATE INDEX idx_memory_priority ON memory_records(priority_score);
```

**Execution Traces (Трассировки):**
```sql
CREATE TABLE execution_traces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    trace_id VARCHAR(255) UNIQUE NOT NULL,  -- OpenTelemetry trace ID
    task_id UUID REFERENCES tasks(id),
    span_id VARCHAR(255),
    parent_span_id VARCHAR(255),
    operation_name VARCHAR(255),
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP,
    duration_ms INTEGER,
    status VARCHAR(20) CHECK (status IN ('success', 'error', 'timeout')),
    attributes JSONB,
    agent_id UUID,
    tool_id UUID
) PARTITION BY RANGE (start_time);

-- Партиционирование по месяцам
CREATE INDEX idx_traces_task ON execution_traces(task_id);
CREATE INDEX idx_traces_agent ON execution_traces(agent_id);
```

### 7.8.2. Стратегия партиционирования
- **execution_traces:** Партиционирование по месяцам (pg_partman)
- **memory_records:** Партиционирование по типам памяти (если объем большой)
- **Архивация:** Автоматическое перемещение старых данных в архивные таблицы

### 7.8.3. Миграции
- Использование Alembic для управления миграциями
- Версионирование схемы БД
- Обратная совместимость при обновлениях
- Стратегия миграции больших объемов данных (постепенная миграция)

---

## 7.9. ПРОИЗВОДИТЕЛЬНОСТЬ И МАСШТАБИРУЕМОСТЬ

### 7.9.1. Оптимизация запросов к БД
- Batch операции где возможно
- Lazy loading для связанных сущностей
- Индексы для частых запросов
- Connection pooling (20-50 соединений)
- Query optimization через EXPLAIN ANALYZE

### 7.9.2. Параллелизм
- Параллельное выполнение независимых шагов плана
- Пул worker'ов для агентов (Celery/Background Tasks)
- Асинхронная обработка утверждений
- Thread pool для I/O операций
- Async/await для неблокирующих операций

### 7.9.3. Мониторинг производительности
**Ключевые метрики:**
- Время ответа API (P50, P95, P99)
- Пропускная способность (requests/second)
- Использование ресурсов (CPU, Memory, GPU)
- Размер очередей задач
- Частота ошибок

**Инструменты:**
- Prometheus для сбора метрик
- Grafana для визуализации
- OpenTelemetry для распределенной трассировки
- Логирование структурированное (JSON)

---

## 8. ТЕХНИЧЕСКИЕ ТРЕБОВАНИЯ

### 8.1. Стек технологий
- **Бэкенд:** Python 3.11+
- **Фреймворки:**
  - LangGraph для оркестрации
  - LangChain для работы с LLM
  - Pydantic для валидации данных
  - FastAPI для веб-сервера
  - SQLAlchemy для работы с БД
- **Базы данных:** PostgreSQL 15+ с расширениями:
  - pgvector для векторного поиска
  - pg_partman для партиционирования (опционально)
- **Локальные модели:** Ollama (поддержка Llama 3.1/3.2, CodeLlama, Gemma, Mistral)
- **Веб-интерфейс:** HTMX + Jinja2 (легковесный подход) или React (по необходимости)
- **Наблюдаемость:** OpenTelemetry, Prometheus, Grafana
- **Контейнеризация:** Docker + Docker Compose (для изоляции выполнения)
- **Безопасность:** SPIFFE/SPIRE для идентификации агентов

### 8.2. Требования к инфраструктуре
**Минимальные требования:**
- Минимум 16 ГБ ОЗУ (рекомендуется 32 ГБ)
- 4+ ядра CPU (рекомендуется 8+)
- 50 ГБ свободного места на диске (рекомендуется 100 ГБ)
- Поддержка контейнеризации (Docker)
- Доступ к интернету для загрузки моделей (опционально, можно локально)

### 8.2.1. Текущая инфраструктура проекта
**Сервер 1 (10.39.0.101) - Основной сервер:**
- **ОС:** Windows Server 2019
- **Контейнеризация:** Docker + Docker Compose
- **RAM:** 80 GB (превышает рекомендации)
- **GPU:** NVIDIA RTX 3070 Ti (для Ollama)
- **Назначение:** Основной хост для AARD Core, PostgreSQL, первый Ollama инстанс
- **Сервисы:**
  - Ollama API: `http://10.39.0.101:11434/v1`
    - Модель: `huihui_ai/deepseek-r1-abliterated:8b`
    - Capabilities: общие задачи, рассуждение, диалог
    - Max concurrent: 2 запроса
  - PostgreSQL 15+ с расширением pgvector: `10.39.0.101:5432`
    - База данных: `aard` ✅ (создана)
    - Пользователь: `postgres`
    - Пароль: `Cdthrf12`
    - **Параметры подключения:**
      ```
      POSTGRES_HOST=10.39.0.101
      POSTGRES_DB=aard
      POSTGRES_USER=postgres
      POSTGRES_PASSWORD=Cdthrf12
      POSTGRES_PORT=5432
      ```

**Сервер 2 (10.39.0.6) - Вторичный сервер:**
- **ОС:** Ubuntu 22.04
- **RAM:** 32 GB (соответствует рекомендациям)
- **GPU:** NVIDIA RTX 3090 (более мощная для кодирования)
- **Назначение:** Второй Ollama инстанс для специализированных задач
- **Сервисы:**
  - Ollama API: `http://10.39.0.6:11434/v1`
    - Модель: `qwen3-coder:30b-a3b-q4_K_M`
    - Capabilities: программирование, генерация кода, анализ кода
    - Max concurrent: 1 запрос (из-за размера модели)

### 8.2.2. Сетевая конфигурация
- **Сеть:** 10.39.0.0/24 (обеспечивает прямое взаимодействие между серверами)
- **Размещение AARD:**
  - **Core Engine:** Сервер 1 (10.39.0.101) - больше RAM, Docker готов
  - **Веб-интерфейс:** Сервер 1 (вместе с Core)
  - **PostgreSQL:** Сервер 1 (10.39.0.101)
  - **Agent Execution:** Docker контейнеры на обоих серверах при необходимости

**Требования к сетевой доступности:**
- [ ] Проверка доступности PostgreSQL из Docker контейнеров на сервере 1
- [ ] Проверка доступности Ollama API с обоих серверов (10.39.0.101 и 10.39.0.6)
- [ ] Настройка firewall правил если необходимо (Windows Firewall на сервере 1)
- [ ] Настройка DNS или hosts файл для разрешения имен (опционально)

### 8.3. Интерфейсы интеграции
- **Внутренние:** REST API для взаимодействия компонентов
- **Внешние:** Поддержка MCP (Model Context Protocol) для инструментов
- **A2A:** Стандартизированный протокол для взаимодействия агентов
- **Безопасность:** SPIFFE для идентификации, OAuth2 для пользователей

---

## 9. НАЧАЛО РАБОТЫ: CHECKLIST ДЛЯ MVP

### 9.0.1. Подготовка инфраструктуры
**Проверка доступности сервисов:**
- [ ] Проверить доступность Ollama API:
  - [ ] `http://10.39.0.101:11434/v1/health` (или `/api/tags`)
  - [ ] `http://10.39.0.6:11434/v1/health`
  - [ ] Проверить список доступных моделей
- [ ] Проверить доступность PostgreSQL:
  - [ ] Подключение с сервера 1 (10.39.0.101)
  - [ ] Проверить версию PostgreSQL (должна быть 15+)
  - [ ] Проверить наличие расширения pgvector
- [ ] Настроить базу данных:
  ```sql
  -- База данных уже создана: aard
  -- Подключиться к базе данных
  \c aard
  
  -- Проверить/установить необходимые расширения
  CREATE EXTENSION IF NOT EXISTS vector;
  CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
  
  -- Проверить текущие расширения
  \dx
  ```
  **Параметры подключения:**
  - Host: `10.39.0.101`
  - Port: `5432`
  - Database: `aard`
  - User: `postgres`
  - Password: `Cdthrf12`
  
  **Команда подключения:**
  ```bash
  psql -h 10.39.0.101 -p 5432 -U postgres -d aard
  # или через Docker:
  docker run -it --rm postgres:15 psql -h 10.39.0.101 -p 5432 -U postgres -d aard
  ```
- [ ] Настроить сетевые правила:
  - [ ] Разрешить доступ между серверами (если нужно)
  - [ ] Открыть необходимые порты (5432 для PostgreSQL, если не локально)
  - [ ] Проверить firewall правила на Windows Server

### 9.0.2. Настройка окружения разработки
**Инициализация проекта:**
- [ ] Инициализировать Git репозиторий
- [ ] Создать структуру проекта:
  ```
  aard/
  ├── backend/
  │   ├── app/
  │   │   ├── __init__.py
  │   │   ├── core/
  │   │   │   ├── __init__.py
  │   │   │   ├── config.py
  │   │   │   ├── database.py
  │   │   │   └── ollama_client.py
  │   │   ├── api/
  │   │   │   ├── __init__.py
  │   │   │   ├── routes/
  │   │   │   └── main.py
  │   │   ├── models/
  │   │   └── services/
  │   ├── tests/
  │   ├── alembic/
  │   ├── requirements.txt
  │   └── main.py
  ├── frontend/
  │   ├── templates/
  │   ├── static/
  │   └── app.py
  ├── docker/
  │   └── Dockerfile
  ├── docker-compose.yml
  ├── .env.example
  ├── .gitignore
  └── README.md
  ```
- [ ] Настроить Docker Compose:
  - [ ] Сервис для backend (FastAPI)
  - [ ] Подключение к внешнему PostgreSQL
  - [ ] Переменные окружения
  - [ ] Volume для персистентности данных

### 9.0.3. Конфигурация для MVP
**Файл .env.example:**
```env
# Database
POSTGRES_HOST=10.39.0.101
POSTGRES_DB=aard
POSTGRES_USER=postgres
POSTGRES_PASSWORD=Cdthrf12
POSTGRES_PORT=5432
DATABASE_URL=postgresql://postgres:Cdthrf12@10.39.0.101:5432/aard
DATABASE_POOL_SIZE=20
DATABASE_MAX_OVERFLOW=10

# Ollama Instance 1 (General/Reasoning)
OLLAMA_URL_1=http://10.39.0.101:11434/v1
OLLAMA_MODEL_1=huihui_ai/deepseek-r1-abliterated:8b
OLLAMA_CAPABILITIES_1=general,reasoning,conversation
OLLAMA_MAX_CONCURRENT_1=2

# Ollama Instance 2 (Coding)
OLLAMA_URL_2=http://10.39.0.6:11434/v1
OLLAMA_MODEL_2=qwen3-coder:30b-a3b-q4_K_M
OLLAMA_CAPABILITIES_2=coding,code_generation,code_analysis
OLLAMA_MAX_CONCURRENT_2=1

# Application
APP_ENV=development
LOG_LEVEL=INFO
SECRET_KEY=<generate_secret_key_here>
API_HOST=0.0.0.0
API_PORT=8000

# Features (для MVP большинство отключено)
ENABLE_AGENT_OPS=false
ENABLE_A2A=false
ENABLE_PLANNING=false
ENABLE_TRACING=false
ENABLE_CACHING=true

# Security
ALLOWED_ORIGINS=http://localhost:8000
```

**Генерация SECRET_KEY:**
```bash
python -c "import secrets; print(secrets.token_urlsafe(32))"
```

**⚠️ ВАЖНО: Безопасность паролей:**
- Файл `.env` содержит реальные пароли и **НЕ должен** попадать в Git
- Убедитесь, что `.env` добавлен в `.gitignore`
- В production используйте переменные окружения или секреты (Docker secrets, Kubernetes secrets)
- Рекомендуется использовать отдельного пользователя БД с ограниченными правами для production
- Рассмотрите использование `.env.local` для локальной разработки и отдельного `.env.production` для production

### 9.0.4. Первые шаги разработки (Неделя 1-2)
**Задачи:**
1. **День 1-2: Базовая инфраструктура**
   - [ ] Настроить FastAPI приложение с базовой структурой
   - [ ] Настроить подключение к PostgreSQL через SQLAlchemy
   - [ ] Создать базовые модели данных (Task, Artifact)
   - [ ] Настроить Alembic для миграций
   - [ ] Создать первую миграцию

2. **День 3-5: Интеграция с Ollama**
   - [ ] Создать Ollama клиент с поддержкой множественных инстансов
   - [ ] Реализовать выбор модели на основе типа задачи
   - [ ] Добавить обработку ошибок и retry логику
   - [ ] Реализовать базовое кэширование ответов

3. **День 6-10: Чат интерфейс**
   - [ ] Создать простой веб-интерфейс (HTMX + Jinja2)
   - [ ] Реализовать API endpoint для чата
   - [ ] Интеграция с Ollama через клиент
   - [ ] Базовая обработка истории сообщений

4. **День 11-14: Управление задачами**
   - [ ] CRUD операции для задач
   - [ ] API endpoints для задач
   - [ ] Базовый интерфейс для просмотра задач
   - [ ] Интеграция задач с чатом

### 9.0.5. Необходимые инструменты для разработки
- [ ] Python 3.11+ установлен
- [ ] Docker и Docker Compose установлены
- [ ] Git установлен и настроен
- [ ] Редактор кода (VS Code, PyCharm, и т.д.)
- [ ] PostgreSQL клиент для тестирования подключений (pgAdmin, DBeaver, psql)
- [ ] Postman или аналогичный инструмент для тестирования API

### 9.0.6. Критерии готовности к началу разработки
- [x] Инфраструктура подготовлена (Ollama, PostgreSQL доступны)
- [x] База данных создана (aard на 10.39.0.101:5432)
- [ ] Расширения pgvector и uuid-ossp установлены в БД
- [ ] Структура проекта создана
- [ ] Docker Compose настроен
- [ ] Переменные окружения настроены (.env файл с реальными параметрами)
- [ ] Разработчик может подключиться к БД (проверено подключение)
- [ ] Разработчик может отправить запрос к Ollama API (оба инстанса)

---

## 10. ЭТАПЫ РАЗРАБОТКИ

### 10.1. Этап 1: Минимальный жизнеспособный продукт (8 недель)
**Цель:** Рабочий прототип с базовой функциональностью
1. Веб-интерфейс с базовым чатом (HTMX + FastAPI)
2. Интеграция Ollama с одной моделью
3. Простой генератор инструментов (шаблонный)
4. Базовая система утверждения артефактов
5. Простая система управления задачами

### 10.2. Этап 2: Механизмы развития (12 недель)
**Цель:** Система, способная создавать простые артефакты
1. Система планирования (высокоуровневая)
2. Улучшенный генератор артефактов (LLM-based)
3. Система тестирования в изоляции (Docker)
4. Трассировка выполнения (OpenTelemetry)
5. A2A взаимодействие (базовое)
6. Долговременная память (pgvector)

### 10.3. Этап 3: Контроль и оптимизация (14 недель)
**Цель:** Надежная система с полным контролем человека
1. Многоуровневая система утверждения
2. LM Judge для оценки качества
3. Система обратной связи и обучения
4. A/B тестирование агентов
5. Оптимизация промптов
6. Уровни автономности
7. Безопасность агентов (идентификация, политики)

### 10.4. Этап 4: Расширенные возможности (10 недель)
**Цель:** Продвинутые возможности для сложных задач
1. Agent Gym (симуляционная среда)
2. Мультимодельная архитектура (заглушки)
3. Визуальный конструктор workflow
4. Инструменты для архитектора
5. Продвинутые интеграции (поиск, VoIP)
6. Механизмы перепланирования

### 10.5. Этап 5: Стабилизация и документация (6 недель)
**Цель:** Готовая к использованию система
1. Нагрузочное тестирование
2. Улучшение UX/UI
3. Полная документация (пользовательская, техническая)
4. Примеры использования от простого к сложному
5. Инструменты миграции и бэкапа

---

## 11. КРИТЕРИИ ПРИЕМКИ

### 11.1. Функциональные критерии
1. Система может создать простой инструмент по описанию (например, поиск файлов)
2. Все создаваемые артефакты проходят утверждение человеком
3. Система отслеживает выполнение задач и предоставляет трассировки
4. Возможность приостановки выполнения на любом этапе
5. Долговременная память сохраняет и извлекает знания
6. Система должна демонстрировать улучшение промптов на основе обратной связи

### 11.2. Критерии качества
1. Время отклика системы < 2 секунд
2. Успешное выполнение простых задач > 90%
3. Полное покрытие трассировками ключевых операций
4. Удобство интерфейса утверждения (оценка пользователей > 4/5)
5. Качество сгенерированного кода > 80% успешных тестов

### 11.3. Критерии безопасности
1. Изоляция выполнения непроверенного кода (Docker)
2. Контроль доступа к ресурсам системы
3. Аудит всех действий пользователей и агентов
4. Защита от инъекций и других уязвимостей
5. Идентификация и аутентификация всех субъектов

### 11.4. Критерии развития
1. Система способна улучшать промпты на основе обратной связи
2. Уменьшение количества ручных вмешательств со временем
3. Увеличение сложности решаемых задач
4. Стабильность работы при долгосрочном использовании

### 11.5. Критерии для системы планирования
1. Способность создавать валидные планы для простых задач
2. Эффективность перепланирования при ошибках
3. Удобство визуализации и управления планами

---

## 12. РИСКИ И МИТИГАЦИЯ

### Риск 1: Сложность управления растущей системой
**Вероятность:** Высокая
**Влияние:** Высокое
**Митигация:** 
- Постепенное развитие с четкими этапами
- Четкие интерфейсы между компонентами
- Инструменты визуализации архитектуры
- Регулярные рефакторинги и аудиты

### Риск 2: Безопасность выполнения сгенерированного кода
**Вероятность:** Средняя
**Влияние:** Критическое
**Митигация:**
- Изоляция в Docker с лимитами ресурсов
- Многоуровневая система утверждения
- Статический анализ кода перед выполнением
- Постепенное увеличение доверия к проверенным артефактам

### Риск 3: Качество генерируемых артефактов
**Вероятность:** Высокая
**Влияние:** Среднее
**Митигация:**
- Многоуровневое тестирование (unit, интеграционное)
- Обратная связь от пользователей
- Постепенное улучшение промптов
- A/B тестирование разных подходов

### Риск 4: Производительность локальных моделей
**Вероятность:** Высокая
**Влияние:** Среднее
**Митигация:**
- Кэширование результатов
- Оптимизация промптов для снижения нагрузки
- Возможность использования более мощного железа
- Выбор оптимальных моделей для разных задач

### Риск 5: Потеря контроля над развитием системы
**Вероятность:** Низкая
**Влияние:** Критическое
**Митигация:**
- Многоуровневые системы утверждения
- Регулярный аудит поведения агентов
- Инструменты мониторинга "дрейфа целей"
- Возможность полного отката к предыдущим состояниям

### Количественная оценка рисков:
| Риск | Вероятность | Воздействие | Общий балл | Приоритет |
|------|-------------|-------------|------------|-----------|
| Компрометация агента | 0.3 | 0.9 | 0.27 | Высокий |
| Некорректное обучение | 0.5 | 0.7 | 0.35 | Высокий |
| Потеря данных | 0.2 | 0.8 | 0.16 | Средний |

KPI митигации:
- Снижение вероятности на 50% за 3 месяца
- Снижение воздействия на 30% за 3 месяца
---

## 13. ДОКУМЕНТАЦИЯ

### 12.1. Техническая документация
1. **Архитектурное описание:** Детальное описание всех компонентов и их взаимодействия
2. **API документация:** OpenAPI спецификации всех endpoints
3. **Руководство по развертыванию:** Пошаговые инструкции для разных окружений
4. **Руководство по разработке расширений:** Как добавлять новые типы агентов и инструментов
5. **Интеграционные руководства:** Как интегрироваться с внешними системами

### 12.2. Пользовательская документация
1. **Руководство пользователя:** Полное описание интерфейса и возможностей
2. **Примеры использования:** От простого к сложному с пошаговыми инструкциями
3. **Best practices:** Как эффективно использовать систему для разных задач
4. **Troubleshooting и FAQ:** Решение распространенных проблем
5. **Видео-туториалы:** Наглядные примеры работы с системой

### 12.3. Документация развития
1. **История изменений:** Хронология развития системы с извлеченными уроками
2. **Roadmap развития:** Планы на будущее с приоритетами
3. **Метрики эффективности:** Как измерять успешность использования системы
4. **Гайды по миграции:** Как обновляться между версиями без потери данных

### 12.4. Операционная документация
1. **Мониторинг и алертинг:** Что мониторить и на что обращать внимание
2. **Процедуры восстановления:** Действия при различных инцидентах
3. **Политики безопасности:** Как обеспечивается безопасность системы
4. **Управление резервными копиями:** Как делать бэкапы и восстанавливаться

---

## 14. МЕТРИКИ УСПЕХА

### 14.1. Метрики развития системы
1. **Скорость создания:** Время от запроса до работающего инструмента < 10 минут
2. **Качество артефактов:** > 80% сгенерированного кода проходит автотесты
3. **Автономность:** Уменьшение ручных утверждений на 50% за 3 месяца
4. **Сложность задач:** Увеличение сложности решаемых задач на 200% за 6 месяцев

### 14.2. Метрики пользовательского опыта
1. **Удовлетворенность:** Средняя оценка пользователей > 4.5/5
2. **Эффективность:** Уменьшение времени на решение типовых задач на 70%
3. **Надежность:** Доступность системы > 99.5%
4. **Прозрачность:** Понимание пользователями решений системы > 90%

### 14.3. Технические метрики
1. **Производительность:** Время отклика < 2 секунд для 95% запросов
2. **Масштабируемость:** Поддержка > 100 параллельных задач
3. **Стабильность:** Среднее время между сбоями > 30 дней
4. **Безопасность:** 0 критических уязвимостей в production

### 14.4. Метрики планирования
1. Точность оценки времени выполнения
2. Эффективность перепланирования (время на адаптацию)
3. Качество планов (процент успешного выполнения без изменений)

### Метрики эволюции промптов:
1. Скорость улучшения (процент прироста эффективности за период)
2. Качество автоматически генерируемых улучшений
3. Снижение необходимости ручной корректировки

---

## 15. ПРИЛОЖЕНИЯ

### Приложение A: Глоссарий терминов
- **AARD:** Autonomous Agentic Recursive Development - название системы
- **Агент:** Автономная программа, способная к целенаправленному поведению
- **Инструмент:** Функция или сервис, который может использовать агент
- **Артефакт:** Общий термин для агентов и инструментов
- **Промпт:** Инструкция для LLM, определяющая поведение агента
- **A2A:** Agent-to-Agent взаимодействие
- **Agent Ops:** Операционное управление жизненным циклом агентов
- **Agent Gym:** Среда для тестирования и развития агентов
- **Дрейф целей:** Непреднамеренное изменение поведения агента со временем

### Приложение B: Примеры сценариев использования
1. **Простой сценарий:** Создание инструмента поиска файлов
2. **Средний сценарий:** Оптимизация конфигурации веб-сервера
3. **Сложный сценарий:** Создание системы мониторинга с алертингом
4. **Эволюционный сценарий:** Постепенное развитие от простого чата к мультиагентной системе

### Приложение C: Матрица соответствия требованиям
Таблица соответствия функциональных требований этапам разработки и критериям приемки.

### **Приложение D: Количественные шкалы и пороговые значения**

**1. Шкала сложности задач:**
```
Уровень 1 (Простой): 1-3 шага, 1 инструмент, автономность 0
Уровень 2 (Средний): 4-7 шагов, 2-3 инструмента, автономность 0-1  
Уровень 3 (Сложный): 8-15 шагов, 4+ инструментов, автономность 1
Уровень 4 (Очень сложный): 16+ шагов, мультиагентная система, автономность 1-2
```

**2. Матрица оценки рисков:**
```yaml
Риск = Вероятность × Воздействие

Вероятность:
- Высокая (0.8-1.0): >30% случаев
- Средняя (0.5-0.8): 10-30% случаев  
- Низкая (0.0-0.5): <10% случаев

Воздействие:
- Критическое (1.0): Необратимый ущерб, потеря данных
- Высокое (0.8): Значительный ущерб, требуется восстановление
- Среднее (0.5): Временные проблемы, ручное вмешательство
- Низкое (0.2): Незначительные неудобства

Пороговые значения:
- Низкий риск: <0.25 → автономное выполнение
- Средний риск: 0.25-0.6 → требуется уведомление
- Высокий риск: >0.6 → требуется утверждение
```

**3. Критерии уверенности модели:**
```
Высокая уверенность (>0.9): низкая энтропия ответов, согласованность
Средняя уверенность (0.7-0.9): умеренная энтропия, небольшие вариации
Низкая уверенность (<0.7): высокая энтропия, противоречивые ответы
```

### **Приложение E: Конкретные процедуры верификации**

**1. Для критерия 11.1.1:** "Система может создать простой инструмент по описанию"
- **Метод проверки:** 10 тестовых запросов разной сложности
- **Успешность:** ≥8/10 созданных инструментов проходят автотесты
- **Инструмент:** автоматический тестовый прогон в Agent Gym

**2. Для критерия 11.3.1:** "Изоляция выполнения непроверенного кода"
- **Метод проверки:** пентест с 5 атаками (инъекции, RCE, etc.)
- **Успешность:** 100% изоляция, 0 компрометаций
- **Инструмент:** Docker security scan + статический анализ

**3. Для критерия 14.1.3:** "Увеличение сложности решаемых задач на 200%"
- **Метод:** сравнение уровня сложности задач на старте и через 6 месяцев
- **Формула:** (средний_уровень_сейчас / средний_уровень_старт) ≥ 3.0
- **Инструмент:** автоматический расчет по логам выполнения

### Приложение F: Таблицы соответствия и проверки
Таблица 1: Соответствие бизнес-целей техническим метрикам

Бизнес-цель			Техническая метрика		Целевое значение
Экономия времени	Время выполнения задач	-70% за 6 мес
Снижение ошибок		Коэффициент успешности	>0.95
Масштабируемость	Параллельных задач		>100
Надежность			Доступность системы		>99.5%

Таблица 2: Критерии устаревания агентов

Критерий		Пороговое значение		Действие
Эффективность	Снижение на 20%			Оптимизация
Использование	<10 раз/месяц			Архивация
Безопасность	Уязвимости CVE			Немедленное обновление
Совместимость	Ошибки интеграции		Замена


---
### **Раздел 16: МЕТОДОЛОГИИ И ПРОЦЕДУРЫ**

#### **15.1 Алгоритм выбора уровня автономности**
```
Вход: задача, контекст, история пользователя
Шаги:
1. Рассчитать риск_задачи = оценка_риска(задача)
2. Получить доверие_пользователя = история_успехов / всего_задач
3. Определить автономность_рекомендуемую:
   - если риск_задачи < 0.25 и доверие_пользователя > 0.8 → 2 (автомат)
   - если риск_задачи < 0.5 и доверие_пользователя > 0.5 → 1 (полуавтомат)
   - иначе → 0 (ручной)
4. Предложить пользователю с возможностью переопределения
```

#### **15.2 Процедура обработки компрометации агента**
```
1. Обнаружение: 
   - Аномальное поведение (сигналы детектирования)
   - Отчеты системы безопасности
   - Алерт от мониторинга

2. Немедленные действия:
   - Изоляция агента (остановка всех процессов)
   - Отзыв всех сертификатов и ключей
   - Блокировка всех исходящих соединений

3. Расследование:
   - Анализ логов и трассировок
   - Определение вектора атаки
   - Оценка ущерба

4. Восстановление:
   - Откат к последней проверенной версии
   - Обновление уязвимых компонентов
   - Полное пересоздание идентификаторов
```

#### **15.3 Методика оценки дрейфа целей**
```
Еженедельный аудит:
1. Собрать метрики за неделю:
   - Качество выполнения задач (LM Judge)
   - Удовлетворенность пользователей
   - Количество ручных вмешательств

2. Рассчитать отклонение от целевых значений:
   отклонение = |факт - цель| / цель

3. Критерии дрейфа:
   - Незначительный: отклонение < 10% по всем метрикам
   - Средний: отклонение 10-25% по 1-2 метрикам
   - Серьезный: отклонение > 25% по любой метрике

4. Действия:
   - Незначительный: мониторинг
   - Средний: корректировка промптов и ограничений
   - Серьезный: полный пересмотр целей и стратегии
```

---

### ДОПОЛНИТЕЛЬНО (часть перенесена в основное тело ТЗ)

# Дополнительные аспекты для рассмотрения в ТЗ AARD

## 1. Механизмы обнаружения и преодоления "старения" агентов

**Проблема:** : "Агенты, развернутые в реальном мире, работают в динамичных средах, где политики, технологии и форматы данных постоянно меняются. Без способности адаптироваться производительность агента со временем снижается — этот процесс часто называют «старением»."

**Рекомендуемые дополнения:**
- **Система мониторинга деградации:** Автоматическое отслеживание снижения эффективности агентов с течением времени
- **Механизмы регрессионного тестирования:** Регулярный прогон тестовых сценариев для выявления ухудшения работы
- **Процесс обновления:** Четкий workflow для замены устаревших агентов на новые версии
- **Метрики старения:** Конкретные показатели для определения необходимости обновления (например, увеличение времени выполнения, снижение точности)

**Реализация:**
```yaml
agent_aging_monitor:
  metrics:
    - performance_degradation: "Снижение эффективности по сравнению с базовой версией"
    - error_rate_increase: "Рост количества ошибок в выполнении задач"
    - context_relevance: "Соответствие текущим условиям и данным"
  thresholds:
    warning: 0.15  # 15% ухудшения
    critical: 0.30 # 30% ухудшения
  actions:
    warning: "Уведомление и рекомендация проверки"
    critical: "Автоматическое создание задачи на обновление"
```

## 2. Глубокая интеграция с экспертами для преодоления "племенного знания"

**Проблема:**: "Agent Gym способен подключаться к человеческой структуре доменных экспертов и консультироваться с ними по поводу правильного набора результатов, которые будут служить ориентиром для следующего набора оптимизаций."

**Рекомендуемые дополнения:**
- **Система экспертного консультативного совета:** Механизм для подключения к экспертам при возникновении сложных задач
- **Протоколы запроса экспертной помощи:** Стандартизированные форматы запросов к экспертам
- **Интеграция экспертных знаний в долговременную память:** Процесс преобразования экспертной информации в формат, пригодный для использования системой
- **Механизмы верификации экспертной информации:** Проверка и валидация полученных от экспертов данных

**Процесс интеграции:**
```
1. Обнаружение сложной задачи, требующей экспертных знаний
2. Формулировка запроса к эксперту с контекстом и вопросами
3. Получение и структурирование экспертной информации
4. Интеграция знаний в долговременную память системы
5. Валидация через тестирование на реальных задачах
6. Документирование источника знаний и уровня доверия
```

## 3. Бизнес-ориентированные метрики и измерение реального влияния

**Проблема:**: "Прежде чем улучшать своего агента, вы должны определить, что означает «лучше» в контексте вашего бизнеса... Эти показатели должны выходить за рамки технической корректности и измерять реальное влияние: коэффициент достижения целей, оценки удовлетворенности пользователей, задержки выполнения задач, операционные затраты на одно взаимодействие и, что наиболее важно, влияние на бизнес-цели, такие как выручка, конверсия или удержание клиентов."

**Рекомендуемые дополнения:**
- **Бизнес-метрики для оценки эффективности:**
  - Влияние на ключевые бизнес-показатели (выручка, конверсия, удержание)
  - Экономия времени и ресурсов
  - Улучшение качества решений
  - Снижение операционных рисков

- **Интеграция с бизнес-аналитикой:**
  - Подключение к существующим системам бизнес-аналитики
  - Создание дашбордов для отслеживания влияния системы на бизнес-метрики
  - A/B тестирование влияния на бизнес-показатели

**Матрица бизнес-метрик:**
| Бизнес-цель | Метрика | Целевое значение | Частота измерения |
|-------------|---------|------------------|-------------------|
| Увеличение выручки | Коэффициент конверсии | +15% | Еженедельно |
| Снижение затрат | Экономия времени | -30% | Ежедневно |
| Улучшение качества | Удовлетворенность клиентов | +20% | Ежемесячно |
| Снижение рисков | Количество ошибок | -50% | Еженедельно |

## 4. Углубленная работа с неопределенностью и сканированием ситуации

**Проблема:**: "Сканирование ситуации: агент воспринимает свое окружение, чтобы собрать контекст. Это включает в себя доступ уровня оркестрации к доступным ресурсам: «Что говорится в запросе пользователя?», «Какая информация находится в моей краткосрочной памяти? Я уже пытался выполнить эту задачу? Пользователь давал мне указания на прошлой неделе?», «К чему я могу получить доступ с помощью своих инструментов, таких как календари, базы данных или API?»."

**Рекомендуемые дополнения:**
- **Расширенный контекстный анализ:**
  - Глубокий анализ запроса пользователя (не только текст, но и подтекст, эмоции, скрытые потребности)
  - Интеграция исторического контекста из долговременной памяти
  - Анализ текущего окружения и доступных ресурсов

- **Механизмы работы с неопределенностью:**
  - Система оценки уровня неопределенности в запросе
  - Стратегии для различных уровней неопределенности
  - Эскалация запросов с высокой неопределенностью

**Модель оценки неопределенности:**
```python
def assess_uncertainty(query, context):
    # Анализ структуры запроса
    structural_uncertainty = analyze_query_structure(query)
    
    # Анализ контекстной ясности
    contextual_uncertainty = analyze_context_clarity(context)
    
    # Анализ эмоциональной окраски
    emotional_uncertainty = analyze_emotional_content(query)
    
    # Общий уровень неопределенности
    total_uncertainty = calculate_weighted_average([
        structural_uncertainty,
        contextual_uncertainty,
        emotional_uncertainty
    ])
    
    # Рекомендуемые действия
    if total_uncertainty > HIGH_THRESHOLD:
        return {
            "level": "high",
            "action": "request_clarification",
            "suggestions": generate_clarification_suggestions(query)
        }
    elif total_uncertainty > MEDIUM_THRESHOLD:
        return {
            "level": "medium",
            "action": "provide_options",
            "suggestions": generate_possible_interpretations(query)
        }
    else:
        return {
            "level": "low",
            "action": "proceed",
            "confidence": 1 - total_uncertainty
        }
```

## 5. Механизмы для работы с конфликтующими целями и приоритетами

**Проблема:** В мультиагентной системе разные агенты могут преследовать конфликтующие цели, что приведет к неэффективности или ошибкам.

**Рекомендуемые дополнения:**
- **Система разрешения конфликтов:**
  - Механизмы выявления конфликтующих целей
  - Алгоритмы приоритизации целей
  - Процесс переговоров между агентами

- **Иерархия целей:**
  - Определение иерархии бизнес-целей
  - Сопоставление целей агентов с бизнес-целями
  - Механизмы пересогласования целей

**Процесс разрешения конфликтов:**
```
1. Обнаружение конфликта целей
   - Анализ целей и намерений участвующих агентов
   - Выявление противоречивых действий или результатов

2. Оценка важности целей
   - Сопоставление с бизнес-приоритетами
   - Оценка потенциального воздействия
   - Учет срочности и временных ограничений

3. Генерация решений
   - Поиск компромиссных вариантов
   - Определение временных приоритетов
   - Создание плана поэтапного достижения целей

4. Утверждение решения
   - Автоматический выбор (при низком уровне конфликта)
   - Предложение пользователю (при среднем/высоком уровне)
   - Интеграция с системой утверждения артефактов

5. Документирование решения
   - Запись в долговременную память
   - Анализ эффективности решения
   - Извлечение уроков для будущих конфликтов
```

## 6. Интеграция с существующими корпоративными системами безопасности

**Проблема:**: "Для управления этой сложностью требуется уровень управления более высокого порядка, интегрирующий все ваши идентификаторы и политики и перенаправляющий их в центральную плоскость управления."

**Рекомендуемые дополнения:**
- **Глубокая интеграция с IAM:**
  - Поддержка существующих систем управления идентификацией и доступом
  - Интеграция с корпоративными каталогами (Active Directory, LDAP)
  - Единый вход и управление сессиями

- **Расширенная политика безопасности:**
  - Интеграция с системами DLP (Data Loss Prevention)
  - Поддержка корпоративных политик шифрования
  - Аудит и отчетность в соответствии с корпоративными стандартами

**Модель интеграции с IAM:**
```
┌─────────────────────────────────────────────────────────┐
│                 Система AARD                            │
├─────────────────────────────────────────────────────────┤
│  • Агенты и инструменты                               │
│  • Долговременная память                              │
│  • Система утверждения                                │
└───────────────┬─────────────────────────────────────────┘
                │
┌───────────────▼─────────────────────────────────────────┐
│                 Плоскость управления                    │
├─────────────────────────────────────────────────────────┤
│  • Централизованное управление идентификацией           │
│  • Политики доступа (ABAC, RBAC)                       │
│  • Аудит и отчетность                                 │
└───────────────┬─────────────────────────────────────────┘
                │
┌───────────────▼─────────────────────────────────────────┐
│          Корпоративные системы безопасности            │
├─────────────────────────────────────────────────────────┤
│  • IAM (Active Directory, LDAP)                        │
│  • DLP системы                                        │
│  • Системы шифрования                                │
│  • SIEM решения                                       │
└─────────────────────────────────────────────────────────┘
```

## 7. Многоуровневая система обработки edge cases и неожиданных сценариев

**Проблема:**: "Генерация тестовых данных: Синтетические датасеты различных типов и сложности, Контролируемое введение аномалий и ошибок, Вариативность условий выполнения, Репрезентативность по отношению к реальным задачам."

**Рекомендуемые дополнения:**
- **Система обнаружения edge cases:**
  - Автоматическое выявление потенциальных edge cases
  - Анализ исторических данных на предмет ранее неучтенных сценариев
  - Интеграция с системой самоанализа

- **Многоуровневая обработка неожиданных ситуаций:**
  - Профилактика (предотвращение возникновения проблем)
  - Обнаружение (раннее выявление аномалий)
  - Адаптация (динамическая корректировка поведения)
  - Отчетность (документирование и извлечение уроков)

**Уровни обработки edge cases:**
```
┌─────────────────────────────────────────────────────────┐
│                  Уровень 1: Профилактика                │
├─────────────────────────────────────────────────────────┤
│  • Предварительный анализ потенциальных проблем         │
│  • Тестирование на граничных условиях                  │
│  • Добавление проверок валидации                       │
└─────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────┐
│                  Уровень 2: Обнаружение                 │
├─────────────────────────────────────────────────────────┤
│  • Мониторинг аномальных паттернов                     │
│  • Анализ отклонений от ожидаемого поведения           │
│  • Система раннего предупреждения                      │
└─────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────┐
│                  Уровень 3: Адаптация                   │
├─────────────────────────────────────────────────────────┤
│  • Динамическое перепланирование                       │
│  • Генерация альтернативных решений                    │
│  • Временное понижение уровня автономности            │
└─────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────┐
│                  Уровень 4: Отчетность                  │
├─────────────────────────────────────────────────────────┤
│  • Документирование инцидента                          │
│  • Анализ первопричин                                  │
│  • Внесение улучшений в систему                        │
└─────────────────────────────────────────────────────────┘
```


Особенно важными являются механизмы обнаружения "старения" агентов и работа с бизнес-ориентированными метриками, так как они непосредственно влияют на долгосрочную ценность системы и ее соответствие бизнес-целям. 