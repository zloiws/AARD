"""
Meta tracker: basic implementation to record component generation/modification
and broadcast meta-events to WebSocket clients.

This is a conservative, minimal implementation used as the foundation for
the full MetaTracker described in docs/implementation/meta_tracker.md.
"""
import asyncio
import json
from datetime import datetime, timezone
from typing import Any, Dict, Optional, List

from sqlalchemy.orm import Session

from app.core.database import SessionLocal
from app.core.logging_config import LoggingConfig

from app.models.evolution import EvolutionHistory, EntityType, ChangeType, TriggerType
from app.models.artifact import Artifact

logger = LoggingConfig.get_logger(__name__)


class MetaTracker:
    """
    Minimal MetaTracker implementation.

    Responsibilities:
    - Record evolution history entries (creation/modification/improvement)
    - Broadcast meta-events to connected WebSocket clients
    - Provide simple queries for evolution graph/timeline
    """

    def __init__(self):
        # Use SessionLocal to create sessions when needed
        self._running = False

    async def start(self) -> None:
        """Start background tasks if needed (metrics collection, subscriptions)."""
        logger.info("Starting MetaTracker")
        self._running = True
        # Placeholder for periodic tasks (metrics, scans)
        asyncio.create_task(self._periodic_noop())

    async def stop(self) -> None:
        """Stop background tasks and cleanup."""
        logger.info("Stopping MetaTracker")
        self._running = False

    async def _periodic_noop(self) -> None:
        """Example background task; real implementation would collect metrics."""
        try:
            while self._running:
                await asyncio.sleep(60)
        except asyncio.CancelledError:
            return

    async def track_code_generation(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """
        Record a new component generation event.

        Expected event keys:
        - name
        - type: 'agent' | 'tool' | 'artifact'
        - created_by (optional)
        - code / prompt (optional)
        - metadata (optional)
        """
        session: Session = SessionLocal()
        try:
            entity_type = EntityType.ARTIFACT
            if event.get("type") == "agent":
                entity_type = EntityType.AGENT

            # If artifact record exists, update; otherwise create minimal artifact
            artifact = None
            name = event.get("name")
            if name:
                artifact = session.query(Artifact).filter(Artifact.name == name).first()

            if not artifact:
                artifact = Artifact(
                    type=event.get("type", "agent"),
                    name=event.get("name", f"component_{datetime.now(timezone.utc).isoformat()}"),
                    description=event.get("description"),
                    code=event.get("code"),
                    prompt=event.get("prompt"),
                    version=1,
                    status="draft",
                    created_by=event.get("created_by"),
                )
                session.add(artifact)
                session.commit()
                session.refresh(artifact)

            # Create evolution history entry
            evolution = EvolutionHistory(
                entity_type=entity_type,
                entity_id=artifact.id,
                change_type=ChangeType.CREATED,
                change_description=event.get("description") or "Generated by system",
                before_state=None,
                after_state={
                    "artifact_id": str(artifact.id),
                    "version": artifact.version,
                    "name": artifact.name,
                },
                trigger_type=TriggerType.MANUAL_REQUEST if event.get("created_by") else TriggerType.AUTO_OPTIMIZATION,
                trigger_data=event.get("metadata", {}),
            )
            session.add(evolution)
            session.commit()
            session.refresh(evolution)

            # Broadcast meta-event (best-effort)
            await self._broadcast_meta_event({
                "type": "component_generated",
                "component_id": str(artifact.id),
                "version": artifact.version,
                "data": {
                    "name": artifact.name,
                    "type": artifact.type,
                    "description": artifact.description,
                }
            })

            return {"artifact_id": str(artifact.id), "evolution_id": str(evolution.id)}
        except Exception as e:
            logger.exception("Failed to track code generation: %s", e)
            session.rollback()
            raise
        finally:
            session.close()

    async def track_code_modification(self, event: Dict[str, Any]) -> Dict[str, Any]:
        """
        Record modification of existing component code.
        Expected event keys:
        - artifact_id or name
        - old_code (optional)
        - new_code (optional)
        - diff (optional)
        - author (optional)
        - metadata (optional)
        """
        session: Session = SessionLocal()
        try:
            artifact = None
            if event.get("artifact_id"):
                artifact = session.query(Artifact).filter(Artifact.id == event["artifact_id"]).first()
            elif event.get("name"):
                artifact = session.query(Artifact).filter(Artifact.name == event["name"]).first()

            if not artifact:
                raise ValueError("Artifact not found for modification")

            before_state = {
                "artifact_id": str(artifact.id),
                "version": artifact.version,
                "name": artifact.name,
            }

            # Update artifact fields if provided
            if "new_code" in event:
                artifact.code = event.get("new_code")
            if "prompt" in event:
                artifact.prompt = event.get("prompt")

            artifact.version = (artifact.version or 1) + 1
            session.add(artifact)
            session.commit()
            session.refresh(artifact)

            evolution = EvolutionHistory(
                entity_type=EntityType.ARTIFACT,
                entity_id=artifact.id,
                change_type=ChangeType.UPDATED,
                change_description=event.get("description") or "Code modification",
                before_state=before_state,
                after_state={
                    "artifact_id": str(artifact.id),
                    "version": artifact.version,
                },
                trigger_type=TriggerType.MANUAL_REQUEST if event.get("author") else TriggerType.AUTO_OPTIMIZATION,
                trigger_data=event.get("metadata", {}),
            )
            session.add(evolution)
            session.commit()
            session.refresh(evolution)

            await self._broadcast_meta_event({
                "type": "component_modified",
                "component_id": str(artifact.id),
                "version": artifact.version,
                "data": {
                    "name": artifact.name,
                    "description": artifact.description,
                }
            })

            return {"artifact_id": str(artifact.id), "evolution_id": str(evolution.id)}
        except Exception as e:
            logger.exception("Failed to track code modification: %s", e)
            session.rollback()
            raise
        finally:
            session.close()

    async def get_evolution_graph(self, entity_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Return a linear timeline or basic graph built from EvolutionHistory.
        If entity_id provided, returns history for that entity.
        """
        session: Session = SessionLocal()
        try:
            query = session.query(EvolutionHistory)
            if entity_id:
                query = query.filter(EvolutionHistory.entity_id == entity_id)
            entries = query.order_by(EvolutionHistory.created_at.asc()).all()
            return [self._evolution_to_dict(e) for e in entries]
        finally:
            session.close()

    def _evolution_to_dict(self, e: EvolutionHistory) -> Dict[str, Any]:
        return {
            "id": str(e.id),
            "entity_type": e.entity_type.value if e.entity_type else None,
            "entity_id": str(e.entity_id) if e.entity_id else None,
            "change_type": e.change_type.value if e.change_type else None,
            "description": e.change_description,
            "before": e.before_state,
            "after": e.after_state,
            "trigger_type": e.trigger_type.value if e.trigger_type else None,
            "trigger_data": e.trigger_data,
            "created_at": e.created_at.isoformat() if e.created_at else None,
        }

    async def _broadcast_meta_event(self, payload: Dict[str, Any]) -> None:
        """Best-effort broadcast to WebSocket connections subscribing to meta events."""
        try:
            # Import manager lazily to avoid circular imports during app startup
            from app.api.routes import websocket_events

            manager = getattr(websocket_events, "manager", None)
            if manager:
                message = {"type": "meta_event", "data": payload}
                await manager.broadcast_to_all(message)
        except Exception:
            # Don't fail the main flow if broadcasting fails
            logger.debug("WebSocket broadcast failed (non-fatal)", exc_info=True)


