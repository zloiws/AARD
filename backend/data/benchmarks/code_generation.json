[
  {
    "name": "factorial_function",
    "task_type": "code_generation",
    "category": "python",
    "task_description": "Write a Python function to calculate the factorial of a non-negative integer n. The function should handle edge cases (n=0, n=1) and use recursion.",
    "expected_output": "def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)",
    "evaluation_criteria": {
      "correctness": 1.0,
      "code_quality": 0.8,
      "edge_cases": 1.0,
      "recursion": 1.0
    },
    "difficulty": "easy",
    "tags": ["python", "recursion", "math"]
  },
  {
    "name": "reverse_string",
    "task_type": "code_generation",
    "category": "python",
    "task_description": "Write a Python function to reverse a string without using built-in reverse methods. Return the reversed string.",
    "expected_output": "def reverse_string(s):\n    return s[::-1]",
    "evaluation_criteria": {
      "correctness": 1.0,
      "code_quality": 0.9,
      "efficiency": 0.8
    },
    "difficulty": "easy",
    "tags": ["python", "string"]
  },
  {
    "name": "binary_search",
    "task_type": "code_generation",
    "category": "python",
    "task_description": "Implement binary search algorithm in Python. The function should take a sorted list and a target value, return the index if found, -1 otherwise.",
    "expected_output": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    "evaluation_criteria": {
      "correctness": 1.0,
      "algorithm": 1.0,
      "edge_cases": 0.9
    },
    "difficulty": "medium",
    "tags": ["python", "algorithm", "search"]
  },
  {
    "name": "fibonacci_sequence",
    "task_type": "code_generation",
    "category": "python",
    "task_description": "Write a Python function that generates the first n numbers in the Fibonacci sequence. Use an efficient approach (avoid naive recursion).",
    "expected_output": "def fibonacci(n):\n    if n <= 0:\n        return []\n    if n == 1:\n        return [0]\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib",
    "evaluation_criteria": {
      "correctness": 1.0,
      "efficiency": 1.0,
      "edge_cases": 0.9
    },
    "difficulty": "medium",
    "tags": ["python", "sequence", "math"]
  },
  {
    "name": "validate_email",
    "task_type": "code_generation",
    "category": "python",
    "task_description": "Write a Python function to validate an email address. It should check for basic format: contains @, has domain part, etc. Return True if valid, False otherwise.",
    "expected_output": "import re\ndef validate_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))",
    "evaluation_criteria": {
      "correctness": 1.0,
      "regex": 0.9,
      "edge_cases": 0.8
    },
    "difficulty": "medium",
    "tags": ["python", "validation", "regex"]
  },
  {
    "name": "merge_sorted_arrays",
    "task_type": "code_generation",
    "category": "python",
    "task_description": "Write a Python function to merge two sorted arrays into one sorted array. Do not use built-in sort functions.",
    "expected_output": "def merge_sorted_arrays(arr1, arr2):\n    result = []\n    i, j = 0, 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n    result.extend(arr1[i:])\n    result.extend(arr2[j:])\n    return result",
    "evaluation_criteria": {
      "correctness": 1.0,
      "algorithm": 1.0,
      "efficiency": 0.9
    },
    "difficulty": "medium",
    "tags": ["python", "algorithm", "array"]
  },
  {
    "name": "palindrome_checker",
    "task_type": "code_generation",
    "category": "python",
    "task_description": "Write a Python function to check if a string is a palindrome (reads the same forwards and backwards). Ignore case and non-alphanumeric characters.",
    "expected_output": "import re\ndef is_palindrome(s):\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s.lower())\n    return cleaned == cleaned[::-1]",
    "evaluation_criteria": {
      "correctness": 1.0,
      "edge_cases": 0.9,
      "code_quality": 0.8
    },
    "difficulty": "easy",
    "tags": ["python", "string", "palindrome"]
  },
  {
    "name": "two_sum",
    "task_type": "code_generation",
    "category": "python",
    "task_description": "Write a Python function that finds two numbers in an array that add up to a target value. Return the indices of the two numbers. Assume exactly one solution exists.",
    "expected_output": "def two_sum(nums, target):\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i",
    "evaluation_criteria": {
      "correctness": 1.0,
      "algorithm": 1.0,
      "efficiency": 1.0
    },
    "difficulty": "medium",
    "tags": ["python", "algorithm", "hash"]
  },
  {
    "name": "remove_duplicates",
    "task_type": "code_generation",
    "category": "python",
    "task_description": "Write a Python function to remove duplicates from a list while preserving the order of first occurrence. Return the list without duplicates.",
    "expected_output": "def remove_duplicates(lst):\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result",
    "evaluation_criteria": {
      "correctness": 1.0,
      "order_preservation": 1.0,
      "efficiency": 0.9
    },
    "difficulty": "easy",
    "tags": ["python", "list", "deduplication"]
  },
  {
    "name": "max_subarray_sum",
    "task_type": "code_generation",
    "category": "python",
    "task_description": "Implement Kadane's algorithm to find the maximum sum of a contiguous subarray in an array of integers. Return the maximum sum.",
    "expected_output": "def max_subarray_sum(arr):\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
    "evaluation_criteria": {
      "correctness": 1.0,
      "algorithm": 1.0,
      "edge_cases": 0.9
    },
    "difficulty": "hard",
    "tags": ["python", "algorithm", "dynamic_programming"]
  }
]

