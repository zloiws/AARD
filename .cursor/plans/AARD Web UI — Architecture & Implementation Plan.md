# AARD Web UI — Architecture & Implementation Plan (Cursor-Controlled)

Документ предназначен **исключительно для проектирования и реализации Web UI** среды AARD под управлением Cursor AI. UI рассматривается не как «фронт», а как **инструмент наблюдаемости, контроля и HITL‑управления**.

Ключевая установка:

> UI обязан объяснять происходящее в системе лучше, чем это мог бы сделать лог.

---

## 0. Архитектурная роль UI

Web UI в AARD:

* не принимает решений
* не содержит бизнес‑логики
* не интерпретирует запросы

UI:

* отображает
* управляет
* подтверждает

Все решения принимаются **в backend‑компонентах** и **явно транслируются в UI**.

---

## 1. Обязательные зоны UI (НЕОБСУЖДАЕМО)

### 1.1 Chat / Interaction Layer

Назначение: точка контакта человека со средой.

Функции:

* ввод пользовательских запросов
* отображение ответов
* отображение уточняющих вопросов (Validator A)
* индикация стадии обработки запроса

Чат **не знает**, кто отвечает — агент, прямой LLM или инструмент.

---

### 1.2 Execution Timeline (ЖИЗНЕННО ВАЖНО)

Назначение: полная трассировка запроса.

Для каждого запроса отображается:

* шаг
* компонент
* system prompt (версия)
* входные данные
* выходные данные
* причина перехода

Формат:

* линейная шкала времени
* раскрываемые блоки

Без Timeline UI считается нефункциональным.

---

### 1.3 Graph View (Nodes & Edges)

Назначение: визуализация архитектуры исполнения.

Отображает:

* компоненты
* агентов
* инструменты
* Registry

Типы нод:

* component
* agent
* tool
* registry
* user

Типы рёбер:

* interpreted_as
* validated_by
* planned_by
* executed_by
* created_by
* queried

Каждое ребро обязано иметь:

* источник
* цель
* причину
* timestamp

---

## 2. Управление средой (Environment Control)

### 2.1 Server & Model Configuration

UI обязан позволять:

* добавлять / удалять серверы
* задавать роли моделей (reasoning / code)
* настраивать API‑ключи
* включать / выключать модели

Любое изменение конфигурации:

* логируется
* требует подтверждения

---

### 2.2 Capabilities & Agents Management

UI отображает Registry:

* список агентов
* список инструментов
* версии промптов
* confidence
* lifecycle

UI **запрещает**:

* ручное создание агентов в обход Factory
* прямое редактирование без истории

---

## 3. HITL‑контроль (Human‑in‑the‑Loop)

Человек обязан подтверждать:

* создание новых capabilities
* создание новых агентов
* изменение границ ответственности

UI должен показывать:

* что предлагается изменить
* кем инициировано
* на основании какого запроса

---

## 4. Отладка и объяснимость (Explainability by Design)

Для любого действия UI должен отвечать на вопросы:

* почему был выбран этот агент?
* почему не использован существующий?
* почему потребовался новый инструмент?
* почему был доступ к БД?

Ответы берутся **из артефактов backend**, а не генерируются UI.

---

## 5. API‑контракт UI ↔ Backend

UI получает:

* Execution Events
* Prompt Metadata
* Registry Snapshots

Backend обязан отдавать:

* reason codes
* decision justifications
* prompt IDs

UI не реконструирует логику самостоятельно.

---

## 6. Cursor — план реализации UI (ПОШАГОВО)

### Этап 1. Event Model

* описать типы событий исполнения
* обеспечить поток событий в UI

### Этап 2. Timeline View

* реализовать линейную трассировку
* раскрытие шагов

### Этап 3. Graph View

* построение графа из событий
* интерактивность

### Этап 4. Registry UI

* read‑only отображение
* diff между версиями

### Этап 5. Configuration UI

* серверы
* модели
* API‑ключи

Каждый этап завершается работающим UI‑артефактом.

---

## 7. Каноническая фиксация

> UI — это не «красиво», а **понятно**.

> Если действие нельзя объяснить в UI — его не должно быть в системе.

Документ является обязательным контрактом для UI‑разработки AARD.
