Хорошо. Делаем **две связанные, но разные вещи** — строго, последовательно и без размывания:

1. **GAP-анализ**: где текущая (типовая для AARD) реализация *почти наверняка* расходится с утверждённой схемой
2. **Каноническое описание типов нод и рёбер** для визуализации (то, что UI и Cursor будут обязаны уважать)

Я намеренно пишу так, чтобы это можно было **прямо положить в Cursor как рабочую спецификацию**, а не как размышления.

---

# ЧАСТЬ 1. GAP-АНАЛИЗ (честно и жёстко)

Я не вижу твоего кода целиком, но по архитектуре, которую ты показывал ранее, можно уверенно указать **структурные разрывы**. Это не упрёки — это нормальный этап.

---

## GAP 1. Нет явного артефакта «Интерпретация»

### Как сейчас (типично)

```
User input → Planner → Plan
```

### Как должно быть

```
User input → Interpretation → Plan
```

### В чём разрыв

* интерпретация «размазана» по планеру / агентам
* невозможно визуализировать **ПОЧЕМУ** запрос был понят именно так
* невозможно отследить смену интерпретационных правил

### Следствие

Ты **не можешь честно показать рост системы**, только смену поведения.

---

## GAP 2. План трактуется как инструкция, а не гипотеза

### Как сейчас

* план создаётся
* выполняется
* если ошибка → новый план

### Проблема

* нет фиксации *ожиданий*
* нет связи «что план обещал» vs «что вышло»

### Следствие

Reflection лишена материала → MetaLearning вырождается в «реакцию».

---

## GAP 3. Human-in-the-loop появляется слишком поздно

### Как сейчас

* человек = approval / feedback

### Как должно быть

* человек = источник:

  * примеров
  * критериев успеха
  * указания *семантического* рассинхрона

### Следствие

Система выглядит «автономной», а не персональной.

---

## GAP 4. MetaLearning логически неотделён от Planning

### Типичная ошибка

* «улучшаем планирование»
* «оптимизируем агента»

### Проблема

* нет **объекта улучшения**
* улучшение превращается в магию

### Следствие

Ты не можешь:

* объяснить изменения
* визуализировать вывод
* ограничить эволюцию

---

## GAP 5. Нет временной онтологии (Timeline — формальность)

### Как сейчас

* логи
* события

### Как должно быть

* **Decision Timeline** как первичный объект
* каждая нода знает *когда и почему* появилась

### Следствие

Нельзя:

* воспроизвести рассуждение
* показать «как я дошёл до этого»

---

## GAP 6. Визуализация не является архитектурным требованием

### Типично

* «потом нарисуем граф»

### По факту

* система уже принимает решения
* но они не обязаны быть визуализируемыми

### Следствие

Визуализация становится «UI-фичей», а не **контрактом архитектуры**.

---

# ЧАСТЬ 2. КАНОНИЧЕСКАЯ МОДЕЛЬ ВИЗУАЛИЗАЦИИ

Это **обязательная спецификация**.
Если компонент нельзя изобразить — он архитектурно неверен.

---

## 1. Общие принципы визуализации

1. Граф **временной**, не статический
2. Каждая нода — **артефакт мышления**, не сервис
3. Каждое ребро отвечает на вопрос **«почему»**, не «куда»
4. Граф воспроизводим (replay)
5. Нет «скрытых» переходов

---

## 2. Типы нод (Node Types)

### 2.1 Human Nodes

#### `HumanIntentNode`

* исходное намерение
* ссылка на raw input
* временная метка

#### `HumanExampleNode`

* пример
* контекст
* НЕ «истина»

#### `HumanFeedbackNode`

* субъективная оценка
* не меняет поведение напрямую

---

### 2.2 Interpretation Nodes

#### `InterpretationNode`

* как система поняла запрос
* применённые InterpretationRules
* уровень уверенности

#### `InterpretationRuleNode`

* правило
* источник
* confidence
* lifecycle (active / decaying / deprecated)

---

### 2.3 Planning Nodes

#### `PlanHypothesisNode`

* цель
* предположения
* ожидаемый результат
* риск

#### `PlanStateNode`

* состояние из PlanLifecycle
* причина перехода

---

### 2.4 Execution Nodes

#### `ExecutionStepNode`

* конкретное действие
* инструмент
* ограничения

#### `ExecutionOutcomeNode`

* результат
* фактические эффекты
* отклонения

---

### 2.5 Reflection Nodes (КЛЮЧЕВЫЕ)

#### `ReflectionNode`

* сравнение ожиданий и результата
* классификация (success / mismatch / failure)
* выводы

#### `DerivedRuleNode`

* новое или обновлённое правило
* степень уверенности
* применимость

---

### 2.6 Temporal Nodes

#### `DecisionCheckpointNode`

* момент выбора
* альтернативы
* почему выбран этот путь

---

## 3. Типы рёбер (Edge Types)

Рёбра **именованные**, это принципиально.

---

### 3.1 Семантические

* `interpreted_as`
* `clarified_by_example`
* `contradicts`

---

### 3.2 Планирование

* `planned_because`
* `assumes`
* `expects`

---

### 3.3 Исполнение

* `executed_via`
* `constrained_by`
* `resulted_in`

---

### 3.4 Рефлексия (основные)

* `matched_expectation`
* `violated_expectation`
* `failed_due_to`
* `revealed_assumption`

---

### 3.5 Эволюция

* `derived_from_reflection`
* `reinforces_rule`
* `weakens_rule`
* `deprecates_rule`

---

## 4. Минимальный обязательный путь в графе

Любой запрос **обязан** порождать путь:

```
HumanIntentNode
  → InterpretationNode
    → PlanHypothesisNode
      → ExecutionStepNode(s)
        → ExecutionOutcomeNode
          → ReflectionNode
            → (optional) DerivedRuleNode
```

Если чего-то нет — **это баг архитектуры**, не UI.

---

## 5. Что это даёт practically

### Для разработки

* Cursor не сможет «схалтурить»
* каждая фича обязана эмитить события

### Для отладки

* видно, где мысль сломалась
* видно, кто «виноват»: интерпретация, план, исполнение

### Для коммерции

* «смотрите, как система думает»
* «вот где она ошиблась»
* «вот почему она стала вести себя иначе»

---

## Финальная фиксация (очень важно)

Ты сейчас делаешь **не ассистента** и **не агента**.

Ты делаешь **среду, в которой мышление обязано быть видимым**.

