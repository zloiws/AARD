# AARD — Prompt-Centric Architecture & Execution Plan (Cursor-Controlled)

Документ предназначен для **прямой загрузки в Cursor AI** как основной план рефакторинга и дальнейшей разработки. Фокус: **жёсткое разделение сущностей, ролей и промптов**, управляемая сборка среды, отсутствие скрытой логики.

---

## 0. Текущий статус проекта (фиксация точки)

На текущем этапе:

* компоненты (оркестратор, валидаторы, агенты, инструменты) **существуют разрозненно**
* логика взаимодействия **частично корректна**, но:

  * промпты не являются первичными артефактами
  * роли моделей смешиваются
  * нет единого контракта исполнения

Цель плана:

> привести систему в состояние, где **каждый компонент = изолированная сущность с собственным system prompt, входами, выходами и границами ответственности**.

---

## 1. Ключевой архитектурный принцип (НЕ ОБСУЖДАЕТСЯ)

> **В AARD поведение определяется промптом, а не кодом.**
> Код лишь связывает промпты и валидирует переходы между ними.

Следствие:

* ни один LLM-вызов не допускается без явного system prompt
* нет «универсального» промпта
* каждая роль закреплена за одним типом промпта

---

## 2. Базовые сущности системы (как кодовые модули)

Каждая сущность ниже:

* отдельный модуль
* отдельный system prompt
* чёткий интерфейс

### 2.1 InterpretationService

**Назначение:** перевод человеческого ввода в StructuredIntent.

* Model: Reasoning
* Prompt type: `interpretation.system`
* Вход: raw user input, user context
* Выход: StructuredIntent
* НЕ имеет права:

  * планировать
  * выбирать инструменты
  * отвечать пользователю результатом

---

### 2.2 Validator A (Semantic Validator)

**Назначение:** проверка корректности интерпретации смысла.

* Model: Reasoning
* Prompt type: `semantic_validator.system`
* Вход: StructuredIntent
* Выход:

  * approved
  * clarification_required
* Имеет право инициировать диалог с человеком

---

### 2.3 Decision Routing Center

**Назначение:** выбор стратегии обработки запроса.

* Model: Reasoning
* Prompt type: `routing.system`
* Вход: StructuredIntent, Capability & Agent Registry
* Выход: RoutingDecision
* НЕ имеет права:

  * создавать агентов
  * исполнять действия

---

### 2.4 PlanningService

**Назначение:** построение гипотезы выполнения.

* Model: Reasoning
* Prompt type: `planning.system`
* Вход: RoutingDecision
* Выход: PlanHypothesis
* План всегда версионируется

---

### 2.5 Capability & Agent Registry

**Назначение:** единый источник знания о возможностях среды.

* Не LLM
* Хранит:

  * capabilities
  * agents
  * confidence
  * lifecycle

Все остальные компоненты **только читают/обновляют через API**.

---

### 2.6 Validator B (Execution Validator)

**Назначение:** проверка допустимости механических действий.

* Model: Reasoning
* Prompt type: `execution_validator.system`
* Вход: PlanHypothesis
* Выход: approved / rejected
* НЕ взаимодействует с пользователем

---

### 2.7 Agent Factory

**Назначение:** создание или обновление агентов/инструментов.

* Decision source: PlanningService
* Execution model: Code
* Prompt type: `agent_builder.system`

---

### 2.8 Execution Agents / Tools

**Назначение:** выполнение конкретных задач.

* Model:

  * Reasoning (если аналитика)
  * Code (если инструменты)
* Prompt type: `agent_<name>.system`
* Ограниченный контекст

---

### 2.9 ReflectionService

**Назначение:** анализ результата и выводы.

* Model: Reasoning
* Prompt type: `reflection.system`
* Выход:

  * rule updates
  * confidence updates
  * registry updates

---

## 3. Две модели — жёсткое распределение

### Reasoning Model

Используется для:

* interpretation
* validation
* planning
* routing
* reflection

### Code Model

Используется ТОЛЬКО для:

* генерации кода
* инструментов
* glue logic
* тестов

Нарушение этого правила = архитектурный дефект.

---

## 4. Порядок выполнения запроса (канонический)

```
User Input
  → InterpretationService
  → Validator A
  → Decision Routing
  → PlanningService
  → Registry lookup
  → Validator B
  → Execution
  → ReflectionService
  → Registry update
```

Оркестратор:

* управляет переходами
* не думает
* не интерпретирует

---

## 5. План движения для Cursor (ПОШАГОВО, УТОЧНЁННЫЙ)

Перед выполнением шагов фиксируется **терминология**, иначе Cursor неизбежно смешает сущности.

### 5.0. Термины и границы (ОБЯЗАТЕЛЬНО)

**Компонент** — логическая сущность, принимающая решения или интерпретирующая данные.

* всегда использует LLM
* всегда имеет собственный `system prompt`
* всегда имеет вход/выход

**Инструмент (Capability)** — механизм выполнения действия.

* LLM *не обязателен*
* `system prompt` не требуется
* имеет строгий интерфейс и ограничения

**Агент** — композиция:

* компонент (мышление)
* * один или несколько инструментов (действие)
* агент **всегда имеет system prompt**

**Среда / Sandbox** — инфраструктура исполнения.

* не компонент
* не агент
* не имеет prompt
* обеспечивает изоляцию и контроль

> Правило: prompt обязателен **только там, где есть интерпретация или решение**.

---

### Этап 1. Инвентаризация (as-is)

Цель: зафиксировать фактическое состояние системы без интерпретаций.

* [ ] перечислить **все точки LLM-вызова** в коде
* [ ] для каждого вызова указать:

  * зачем он существует
  * какой результат ожидается
  * есть ли у него явный system prompt
* [ ] классифицировать каждый вызов:

  * компонент
  * агент
  * утилитарный (временный, под удаление)
* [ ] зафиксировать вызовы без роли как **архитектурные дефекты**

Результат этапа: таблица `llm_calls_inventory.md`.

---

### Этап 2. Декомпозиция на компоненты

Цель: привести мышление системы к атомарным ролям.

Для каждого компонента:

* [ ] формально описать ответственность (1 абзац)
* [ ] определить входные данные
* [ ] определить выходные данные
* [ ] создать **минимальный, строгий system prompt**
* [ ] запретить любую побочную логику

Компоненты минимального состава:

* InterpretationService
* ValidatorA (Semantic)
* DecisionRouting
* PlanningService
* ValidatorB (Execution)
* ReflectionService

Результат этапа: папка `/prompts/components/`.

---

### Этап 3. Инструменты и Sandbox

Цель: отделить действие от мышления.

* [ ] перечислить все существующие инструменты
* [ ] описать для каждого:

  * интерфейс
  * ограничения
  * побочные эффекты
* [ ] удалить любые LLM-вызовы из инструментов
* [ ] формализовать Sandbox как инфраструктурный слой

Результат этапа: `capabilities_registry.json`.

---

### Этап 4. Registry (Capabilities & Agents)

Цель: создать единственный источник правды о среде.

* [ ] реализовать Registry как отдельный модуль
* [ ] хранить:

  * агенты (prompt version, роль, confidence)
  * инструменты (interface, constraints)
  * lifecycle (active / weak / deprecated)
* [ ] запретить прямое использование агентов и инструментов без Registry

Результат этапа: API Registry + схема данных.

---

### Этап 5. Agent Factory

Цель: централизовать создание и модификацию агентов.

* [ ] запретить создание агентов вне Factory
* [ ] Factory использует только Code Model
* [ ] вход: запрос PlanningService
* [ ] выход: зарегистрированный агент
* [ ] каждая операция логируется и версионируется

Результат этапа: модуль `agent_factory`.

---

### Этап 6. Валидаторы как предохранители

Цель: исключить неконтролируемые переходы.

* [ ] ValidatorA:

  * работает только с семантикой
  * может задавать вопросы человеку
* [ ] ValidatorB:

  * проверяет допустимость действий
  * не взаимодействует с пользователем
* [ ] валидаторы не могут инициировать execution

Результат этапа: два независимых компонента.

---

### Этап 7. Связывание через Оркестратор

Цель: обеспечить детерминированную последовательность.

* [ ] оркестратор управляет только стадиями
* [ ] не имеет system prompt
* [ ] не использует LLM
* [ ] вся логика решений вынесена в компоненты

Результат этапа: чистый state-machine.

---

### Этап 8. Reflection → Update

Цель: управляемое самоизменение.

* [ ] ReflectionService анализирует результат
* [ ] формирует:

  * обновление confidence
  * предложения по улучшению промптов
* [ ] любые изменения проходят через Registry

Результат этапа: контролируемая эволюция системы.

---

## 6. Контроль для человека (обязательно)

* человек подтверждает:

  * создание новых capabilities
  * изменение границ
* человек видит:

  * какие промпты использовались
  * какие решения приняты

---

## 7. Каноническая фиксация

> **Если компонент не имеет собственного промпта — он не существует.**

> **Если LLM вызвана без явной роли — это баг.**

---

Документ является архитектурным контрактом.
Любые изменения должны начинаться с правки этого плана, а не кода.
