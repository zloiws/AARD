# Оптимизация PlanningService

## ✅ Выполнено

### Объединение _analyze_task() и _decompose_task() в один запрос

**Файл:** `backend/app/services/planning_service.py`

**Изменения:**

#### 1. Новый метод `_analyze_and_decompose_task_optimized()`
- Объединяет анализ задачи и декомпозицию в один запрос к LLM
- Использует structured output для получения обоих результатов одновременно
- Уменьшает латентность на ~50% (один запрос вместо двух)
- Улучшает согласованность результатов (анализ и декомпозиция на основе одного контекста)

#### 2. Интеграция в `generate_plan()`
- Заменен последовательный вызов `_analyze_task()` и `_decompose_task()`
- Используется новый оптимизированный метод
- Fallback на последовательные вызовы при ошибках или таймауте

#### 3. Вспомогательные методы
- `_get_combined_analysis_decomposition_prompt()` - получение промпта для объединенного запроса
- `_build_combined_planning_prompt()` - построение промпта с контекстом

## Преимущества

1. **Производительность:**
   - Один запрос к LLM вместо двух
   - Снижение латентности на ~50%
   - Меньше сетевых вызовов

2. **Согласованность:**
   - Анализ и декомпозиция на основе одного контекста
   - Меньше расхождений между стратегией и шагами

3. **Надежность:**
   - Fallback на последовательные вызовы при ошибках
   - Таймаут увеличен на 50% для объединенного запроса

## Формат ответа

LLM возвращает JSON с двумя частями:

```json
{
    "analysis": {
        "goal": "основная цель",
        "requirements": ["требование 1"],
        "constraints": ["ограничение 1"],
        "success_criteria": ["критерий 1"],
        "complexity": "simple|medium|complex",
        "estimated_steps": число
    },
    "steps": [
        {
            "step_id": "step_1",
            "description": "описание шага",
            "type": "action|decision|validation",
            "dependencies": [],
            "inputs": {},
            "expected_outputs": {},
            "timeout": 60,
            "retry_policy": {"max_attempts": 3, "delay": 10},
            "approval_required": false,
            "risk_level": "low|medium|high"
        }
    ]
}
```

## Обратная совместимость

- Старые методы `_analyze_task()` и `_decompose_task()` сохранены
- Используются как fallback при ошибках оптимизированного метода
- Могут использоваться для других целей (например, перепланирование)

## Метрики

- **Латентность:** Снижение на ~50% (один запрос вместо двух)
- **Согласованность:** Улучшение за счет единого контекста
- **Надежность:** Fallback механизм обеспечивает отказоустойчивость

