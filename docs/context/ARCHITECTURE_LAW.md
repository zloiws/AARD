# ARCHITECTURE_LAW — AARD

Данный документ фиксирует **архитектурные законы проекта AARD**.

Он является **единственным нормативным источником**, определяющим:

* допустимые сущности системы;
* границы ответственности;
* правила взаимодействия;
* приоритеты между кодом, промптами и оркестрацией.

Все новые изменения в коде, документации и UI **обязаны соответствовать этому документу**.

---

## 1. Базовый принцип AARD

> **AARD — это персональная среда взаимодействия человека и ИИ, основанная на примерах, саморефлексии и наблюдаемом принятии решений.**

Следствия:

* человек является **основой системы**, а не внешним пользователем;
* система не «знает», а **формирует гипотезы**;
* обучение происходит **через рефлексию успешных и неуспешных действий**, а не через прямую корректировку поведения.

---

## 2. Prompt-Centric закон (ключевой)

> **Поведение системы определяется промптами, а не кодом.**

Код выполняет только:

* связывание компонентов;
* передачу данных;
* контроль переходов;
* обеспечение безопасности и изоляции.

### Следствия:

* любой LLM-вызов без явного `system prompt` считается архитектурной ошибкой;
* универсальных промптов не существует;
* если сущность принимает решение или интерпретирует смысл — у неё обязан быть собственный system prompt.

---

## 3. Канонические сущности системы

### 3.1. Компонент (Component)

**Определение:**
Логическая сущность, принимающая решения или интерпретирующая данные.

Признаки:

* всегда использует LLM;
* всегда имеет собственный `system prompt`;
* имеет чётко определённые входы и выходы;
* не исполняет действий напрямую.

Примеры:

* InterpretationService
* PlanningService
* ValidatorA / ValidatorB
* ReflectionService

---

### 3.2. Инструмент (Capability)

**Определение:**
Механизм выполнения конкретного действия.

Признаки:

* может не использовать LLM;
* не интерпретирует смысл;
* имеет строгий интерфейс;
* system prompt **не обязателен**.

Примеры:

* HTTP client
* Database query
* File system access

---

### 3.3. Агент (Agent)

**Определение:**
Композиция мышления и действия.

Состав:

* как минимум один компонент (мышление);
* один или несколько инструментов (действие).

Правила:

* агент **всегда имеет system prompt**;
* агент не может существовать без описанных инструментов;
* агент создаётся, обновляется или удаляется осознанно через Factory.

---

### 3.4. Среда / Sandbox

**Определение:**
Инфраструктура исполнения.

Признаки:

* не является компонентом;
* не является агентом;
* не имеет system prompt;
* обеспечивает изоляцию, безопасность и контроль выполнения.

---

## 4. Контрактный закон

> **Любое взаимодействие допустимо только при наличии задокументированного контракта.**

Контракт обязателен для:

* внешних API сервисов;
* внутренних API модулей;
* LLM-вызовов (prompt + ожидаемый вывод);
* событий и переходов стадий.

Отсутствие контракта означает:

* взаимодействие архитектурно недопустимо;
* оркестрация не имеет права использовать сущность.

---

## 5. Сначала контракты — потом оркестрация

> **Нельзя проектировать поведение системы через оркестрацию недоописанных сервисов.**

Правильная последовательность:

1. Определение сущности;
2. Фиксация входов/выходов;
3. Фиксация system prompt (если применимо);
4. Документация гарантий;
5. Только после этого — включение в workflow.

---

## 6. Закон Registry (единственный источник истины)

* Registry хранит:

  * агентов;
  * capabilities;
  * версии;
  * confidence;
  * lifecycle.

Правила:

* прямое знание о возможностях среды вне Registry запрещено;
* дублирующие агенты и инструменты считаются дефектом архитектуры;
* любые изменения проходят через Registry API.

---

## 7. Две модели — два типа ответственности

### Reasoning Model

Используется для:

* интерпретации;
* планирования;
* маршрутизации;
* валидации;
* рефлексии.

### Code Model

Используется только для:

* генерации кода;
* реализации инструментов;
* glue-логики;
* тестов.

Смешение ролей считается архитектурной ошибкой.

---

## 8. Закон наблюдаемости (Observability)

> **Если процесс нельзя восстановить по событиям — он считается несуществующим.**

Обязательное:

* каждая стадия эмитит событие;
* событие содержит:

  * component;
  * prompt_id + version;
  * reason_code;
  * вход/выход (summary);
* UI не интерпретирует логику, а отображает факты.

---

## 9. Закон человека в контуре (HITL)

* человек подтверждает:

  * создание новых агентов;
  * добавление новых инструментов;
  * расширение границ среды.

* человек видит:

  * какие решения приняты;
  * почему они приняты;
  * на основе каких промптов.

---

## 10. Правило эволюции

* система не «обучается» напрямую;
* изменения происходят через:

  * ReflectionService;
  * обновление правил;
  * обновление confidence;
  * обновление Registry.

Прямое изменение поведения без рефлексии запрещено.

---

## 11. Каноническая фиксация

> **Если сущность принимает решение — у неё есть system prompt.**

> **Если LLM вызвана без явной роли — это баг.**

> **Если взаимодействие не задокументировано — его не существует.**

---

Этот документ не является описанием реализации.
Он является **архитектурным законом**, обязательным для исполнения.

---

## 12. План lifecycle и отказоустойчивость

Все планы (Plan / PlanHypothesis) проходят формальный lifecycle:

- DRAFT — план сгенерирован, требует проверки
- APPROVED — явное человеческое или автоматическое одобрение, только после этого возможен EXECUTING
- EXECUTING — план выполняется в Sandbox/ExecutionService
- COMPLETED — план успешно завершён
- FAILED — выполнение провалилось; требует анализа и/или ре-планирования
- CANCELLED — отменён вручную

Правило: вызов выполнения плана запрещён, если статус != APPROVED.
Все переходы фиксируются в ExecutionEvent + WorkflowEvent с объяснением reason_code и decision_source.

---

## 13. Управление промптами и версияция

Правила:
- Canonical prompts хранятся на диске (prompts/components/*.system) и регулярно seed'ятся в DB.
- В DB хранится версия промпта; при назначении обязательно указывать prompt_id и prompt_version.
- PromptAssignment имеет scope: global | agent | experiment и разрешение применить:
  1) experiment (если задан matching experiment_id/session_id)
  2) agent (если задан agent_id)
  3) global (fallback)
  4) disk‑canonical (последний fallback)

Каждый LLM‑вызов в runtime обязан пройти через PromptSelector, который возвращает system_prompt, prompt_id и prompt_version.

---

## 14. Контроль и политика документации (Governance)

1) Нормативность:
- `ARCHITECTURE_LAW.md` — единственный нормативный источник, остальные docs должны ссылаться на него.

2) PR политика:
- Любой PR, изменяющий поведение сервиса (внутреннюю логику, контракты, LLM‑вызовы), должен включать или обновлять `docs/services/<service>.md` с:
  - Input DTO
  - Output DTO
  - Service_role (одно предложение)
  - Используемые prompts (prompt_id/prompt_version/component_role) или явное заявление, что LLM не используется.

## Development policy (LOCAL-FIRST)

AARD is a personal, local-first, exploratory development project. While PRs and CI pipelines
are useful for mature, multi-contributor projects, during the architecture stabilization phase
the canonical project workflow is intentionally lightweight and local-first:

- PRs and CI are disabled by default for routine development until architectural contracts are frozen.
- Use Git as a journal of design and decisions (direct commits, small atomic commits, descriptive messages).
- Example commit message styles:
  - `architecture: add orchestration readiness checklist`
  - `docs: freeze ARCHITECTURE_LAW`
+- PRs and CI are required only when:
-  - architectural contracts are frozen,
-  - external contributors exist,
-  - plugins/third-party agents are integrated,
-  - Registry/Capability APIs are stabilized.

This policy prioritizes rapid exploration and correctness of contracts over early gatekeeping.

3) CI enforcement (рекомендуется, но выключено по умолчанию):
- Когда проект переходит в multi-contributor стадию, добавить CI‑hook, который блокирует merge если PR изменяет код сервиса без соответствующего `docs/services/<service>.md` обновления.

---

## 15. Observability & Events (enforcement)

Дополнение к разделу Observability:
- Все события и ExecutionEvent обязаны включать как минимум:
  - component_role
  - prompt_id, prompt_version (если применимо)
  - decision_source (component | registry | human)
  - input_summary, output_summary
  - reason_code / justification

UI отображает события без дополнительной интерпретации; объяснения и корректность даёт backend (через justification + metadata).

---

## 16. Владелец и словарь терминов (Ownership & Glossary)

- Каждый сервисный документ должен содержать поле `owner` (team, person, email) — это контакт для вопросов и утверждений.
- Добавлен краткий glossary:
  - Component — логическая роль, использует LLM, имеет system prompt.
  - Capability — инструмент / действие.
  - Agent — композиция component + capabilities.
  - Sandbox — изолированная среда выполнения.

---

## 17. Runbook миграций и maintenance notes

Короткое резюме для инженеров:
- Всегда писать миграции идемпотентно (IF NOT EXISTS / IF EXISTS).
- При возникновении multiple heads — создавать merge‑migration, но предварительно проверить что не возникает дублирующих DDL (колонок/индексов).
- Seed canonical prompts из диска в DB через `backend/scripts/seed_prompts_from_disk.py` и логировать отличия.

Полный runbook положить в `docs/roadmap/migration_runbook.md`.