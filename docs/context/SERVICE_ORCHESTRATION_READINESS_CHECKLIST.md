# SERVICE ORCHESTRATION READINESS CHECKLIST (AARD)

> **Назначение документа**
> Данный чеклист — обязательный фильтр перед **любой оркестрацией**.
> Он применяется к сервисам, модулям, компонентам, агентам и инструментам.
>
> Если пункт не выполнен — сущность **НЕ ДОПУСКАЕТСЯ** к оркестрации.
> Частичная готовность = неготовность.

Документ является операционным продолжением `ARCHITECTURE_LAW.md`.

---

## 0. Идентификация сущности (КРИТИЧЕСКИ)

* [ ] Указано **однозначно**, чем является сущность:

  * Service (внешняя логическая единица)
  * Module (внутренний модуль сервиса)
  * Component (LLM-мышление)
  * Capability / Tool (исполнение)
  * Agent (Component + Capability)

* [ ] Сущность **строго соответствует определениям** из `ARCHITECTURE_LAW.md`

* [ ] Сущность **не пытается быть несколькими типами одновременно**

> ❗ Если тип сущности вызывает спор или требует объяснений — FAIL.

---

## 1. Границы ответственности (MUST)

* [ ] Чётко описано, **что сущность делает**

* [ ] Чётко описано, **чего сущность НЕ делает**

* [ ] Сущность не:

  * интерпретирует и исполняет одновременно
  * планирует и валидирует одновременно
  * принимает решения без формального входа

> ❗ Размытые формулировки ответственности = FAIL.

---

## 2. Контракты входа / выхода (HARD REQUIREMENT)

### 2.1. Вход

* [ ] Формализован вход:

  * DTO / schema / model
  * обязательные поля
  * допустимые значения

* [ ] Описаны предположения о входных данных

### 2.2. Выход

* [ ] Формализован выход:

  * структура результата
  * статусы

* [ ] Формализованы ошибки:

  * код
  * семантика

### 2.3. Гарантии

* [ ] Зафиксированы гарантии:

  * идемпотентность
  * side-effects
  * требования к валидации

> ❗ Формулировка «используется как сейчас» = FAIL.

---

## 3. LLM-использование (ЕСЛИ ПРИМЕНИМО)

### 3.1. Факт использования

* [ ] Использует ли сущность LLM?

  * да / нет

Если **да**:

### 3.2. Роль LLM

* [ ] Зафиксирована роль LLM:

  * интерпретация
  * планирование
  * валидация
  * рефлексия

* [ ] Используемая модель указана:

  * Reasoning
  * Code

### 3.3. System Prompt

* [ ] Есть собственный `system prompt`

* [ ] Зафиксированы:

  * prompt_id
  * версия

* [ ] Описано:

  * какие решения разрешены
  * какие решения запрещены

> ❗ LLM без system prompt = архитектурный дефект.

---

## 4. Место в архитектурной цепочке

* [ ] Указана стадия жизненного цикла запроса:

  * Interpretation
  * Validator A
  * Routing
  * Planning
  * Validator B
  * Execution
  * Reflection

* [ ] Сущность **не перескакивает стадии**

* [ ] Сущность **не ломает канонический порядок**

> ❗ Несанкционированный переход стадий = FAIL.

---

## 5. Registry (ЕДИНСТВЕННЫЙ ИСТОЧНИК ПРАВДЫ)

* [ ] Сущность зарегистрирована в Registry

* [ ] Имеет уникальный идентификатор

* [ ] Зафиксирован lifecycle:

  * created
  * active
  * deprecated

* [ ] Проверено отсутствие функциональных дубликатов

> ❗ Оркестратор не имеет права знать о сущности вне Registry.

---

## 6. Наблюдаемость и трассировка (OBSERVABILITY)

* [ ] Сущность эмитит события выполнения

Каждое событие содержит:

* [ ] component / service name

* [ ] stage

* [ ] prompt_id + version (если LLM)

* [ ] reason_code

* [ ] input_summary

* [ ] output_summary

* [ ] По событиям возможно восстановить:

  * причину вызова
  * ход выполнения
  * результат

> ❗ Ненаблюдаемая сущность считается несуществующей.

---

## 7. HITL — человек в контуре

* [ ] Определено, требуется ли подтверждение человека

Если требуется:

* [ ] Зафиксированы точки подтверждения
* [ ] UI способен отобразить:

  * решение
  * причину
  * альтернативы (если были)

---

## 8. Тестируемость

* [ ] Сущность имеет изолированные тесты

* [ ] Тесты покрывают:

  * валидные входы
  * невалидные входы
  * граничные состояния

* [ ] Поведение детерминировано в рамках контракта

> ❗ Непроверяемая сущность не подлежит оркестрации.

---

## 9. Финальное решение

Сущность может быть подключена к оркестратору **ТОЛЬКО ЕСЛИ**:

* [ ] Все пункты 1–8 выполнены
* [ ] Нет нарушений `ARCHITECTURE_LAW.md`
* [ ] Назначение сущности понятно **без чтения кода**

Если хотя бы один пункт не выполнен:

> **СУЩНОСТЬ НЕ ГОТОВА К ОРКЕСТРАЦИИ.**

---

## Каноническая фиксация

> Оркестратор не лечит архитектуру.

> Оркестратор связывает только зрелые сущности.

> Если требуется объяснять — значит, не готово.

---

## 10. PROMPT & PROMPT ASSIGNMENT REQUIREMENTS (MUST)

* [ ] Каждая сущность, использующая LLM, имеет явно привязанный `system prompt` (prompt_id + version).
* [ ] Для каждой привязки (`PromptAssignment`) зафиксированы поля:
  * `component_role` (явная роль компонента, например interpretation/planning/execution)
  * `stage` (жизненный этап запроса)
  * `scope` (global | agent | experiment)
  * `agent_id` / `experiment_id` (если применимо)
* [ ] Разрешение промпта в рантайме следует порядку: experiment → agent → global → disk (fallback).
* [ ] Изменение привязки/версии промпта требует аудита и записи в Timeline как system event.

> ❗ Отсутствие `component_role` или неопределённый `scope` = архитектурный дефект.

---

## 11. EXECUTION EVENT & DECISION SOURCE

Каждое событие выполнения (`WorkflowEvent` / `ExecutionEvent`) должно содержать:

* [ ] `component` / `component_role`
* [ ] `stage` (Interpretation, ValidatorA, Routing, Planning, ValidatorB, Execution, Reflection)
* [ ] `prompt_id` + `prompt_version` (если LLM использовался)
* [ ] `decision_source`: one of `component` | `registry` | `human`
* [ ] `reason_code`, `input_summary`, `output_summary`, `timestamp`, `trace_id`

> ❗ `decision_source` обязателен для всех событий, участвующих в HITL или affecting plan lifecycle.

---

## 12. PROMPT RESOLUTION & RUNTIME SAFEGUARDS

* [ ] В рантайме должна работать служба разрешения промптов (PromptRuntimeSelector) — возвращать конкретный prompt_text и метаданные источника (`experiment|agent|global|disk`).
* [ ] Если разрешённый промпт имеет статус `deprecated` — оркестратор должен отклонить исполнение и требовать обновления (HITL).
* [ ] A/B тестирование и экспериментальные версии могут применяться только при явно включённом флаге в контексте (workflow/execution metadata).

---

## 13. GRAPH / OBSERVABILITY REQUIREMENTS

* [ ] Система должна предоставлять API `/api/events/graph` возвращающий объекты `nodes` и `edges` для визуализации causal graph.
* [ ] Нода содержит: `id`, `label`, `type` (User|Component|Agent|Tool|Registry), `metadata` (minimal).
* [ ] Ребро содержит: `source`, `target`, `label`, `reason_code`, `timestamp`.
* [ ] UI визуализация Graph — только read-only, строится полностью из `ExecutionEvent`.
* [ ] Клик по ноде/ребру в UI раскрывает связанные события в Timeline (cross-highlight).

> ❗ Graph — не источник истины для принятия решений; только наблюдаемость.

---

## 14. CI / GATE CHECKS (RECOMMENDED)

* [ ] PR, затрагивающий любую сущность, должна проходить проверку:
  * наличие service/module/component описания в `docs/` по шаблону `docs/templates/service_template.md`
  * если добавляется LLM-вызов — наличие system prompt на диске и теста, что prompt загружается
  * миграции должны быть идемпотентны (повторный запуск не должен падать)
* [ ] Автоматическая статическая проверка contracts (schema) для `ExecutionEvent` и `PromptAssignment`.

> ❗ Несоблюдение CI/Gate — признак неготовности к оркестрации.
